{
  "version": 3,
  "sources": ["../../fn/modules/cache.js", "../../fn/modules/curry.js", "../../fn/modules/overload.js", "../../fn/modules/choose.js", "../../fn/modules/id.js", "../../dom/modules/request.js", "../library/request.js", "../../dom/modules/fragment-from-html.js", "../../fn/modules/get-path.js", "../../fn/modules/noop.js", "../../fn/modules/nothing.js", "../../dom/modules/identify.js", "../../dom/modules/is-text-node.js", "../../dom/modules/to-type.js", "../../fn/modules/by.js", "../../fn/modules/exec.js", "../../fn/modules/capture.js", "../../fn/modules/equals.js", "../../fn/modules/matches.js", "../../fn/modules/slugify.js", "../../fn/modules/last.js", "../../fn/modules/to-type.js", "../../fn/modules/parse-value.js", "../../dom/modules/style.js", "../../dom/modules/parse-length.js", "../../fn/observer/observer.js", "../../fn/stream/stream.js", "../../fn/observer/observable.js", "../../fn/stream/combine.js", "../../fn/observer/observe.js", "../../fn/stream/merge.js", "../../fn/stream/zip.js", "../modules/library.js", "../../fn/modules/get.js", "../../fn/modules/compile.js", "../modules/renderers/analytics.js", "../modules/compile.js", "../../fn/observer/reads.js", "../modules/renderers/batcher.js", "../modules/to-text.js", "../modules/renderers/renderer.js", "../modules/renderers/attribute-renderer.js", "../modules/renderers/boolean-renderer.js", "../../fn/modules/is-defined.js", "../../dom/modules/event.js", "../../dom/modules/trigger.js", "../modules/config.js", "../modules/renderers/checked-renderer.js", "../../dom/modules/assign.js", "../../dom/modules/create.js", "../modules/renderers/content-renderer.js", "../modules/renderers/tokens-renderer.js", "../modules/renderers/value-renderer.js", "../modules/decode.js", "../modules/compile-node.js", "../modules/renderers/template-renderer.js", "../library/include.js", "../../dom/modules/log.js", "../../dom/modules/element.js", "../elements/literal-include.js", "../modules/analytics.js", "../module.js"],
  "sourcesContent": ["/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)`\nagainst input values in a map, such that for each input value\n`fn` is only ever called once.\n*/\n\nexport default function cache(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && object === undefined) {\n            console.warn('cache() called with undefined.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "/**\noverload(fn, map)\n\nReturns a function that calls a function at the property of `object` that\nmatches the result of calling `fn` with all arguments.</p>\n\n```\nvar fn = overload(toType, {\n    string: function a(name, n) {...},\n    number: function b(n, m) {...}\n});\n\nfn('pie', 4); // Returns a('pie', 4)\nfn(1, 2);     // Returns b(1, 2)\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no handler for \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\nchoose(fn, map)\nReturns a function that takes its first argument as a key and uses it\nto select a function in `map` which is invoked with the remaining arguments.\n\nWhere `map` has a function `default`, that function is run when a key\nis not found, otherwise unfound keys will error.\n\n```\nvar fn = choose({\n    'fish':  function fn1(a, b) {...},\n    'chips': function fn2(a, b) {...}\n});\n\nfn('fish', a, b);   // Calls fn1(a, b)\n```\n*/\n\nexport default function choose(map) {\n    return function choose(key, ...params) {\n        var fn = map[key] || map.default;\n        return fn && fn.apply(this, params) ;\n    };\n}\n", "/**\nid(value)\nReturns `value`.\n*/\n\nexport default function id(value) { return value; }\n", "import choose  from '../../fn/modules/choose.js';\nimport id      from '../../fn/modules/id.js';\n\nconst assign = Object.assign;\n\n/*\nconfig\n\n```{\n    headers:    fn(data),    // Must return an object with properties to add to the header\n    body:       fn(data),    // Must return an object to send as data\n    onresponse: function(response)\n}```\n*/\n\nexport const config = {\n    // Takes data, returns headers\n    headers: function(data) { return {}; },\n\n    // Takes data (can be FormData object or plain object), returns data\n    body: id,\n\n    // Takes response, returns response\n    onresponse: function(response) {\n        // If redirected, navigate the browser away from here. Can get\n        // annoying when receiving 404s, maybe not a good default...\n        if (response.redirected) {\n            window.location = response.url;\n            return;\n        }\n\n        return response;\n    }\n};\n\nconst createHeaders = choose({\n    'application/x-www-form-urlencoded': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'application/json': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'multipart/form-data': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'multipart/form-data',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'audio/wav': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'audio/wav',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'default': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    }\n});\n\nconst createBody = choose({\n    'application/json': function(data) {\n        return data.get ?\n            formDataToJSON(data) :\n            JSON.stringify(data);\n    },\n\n    'application/x-www-form-urlencoded': function(data) {\n        return data.get ?\n            formDataToQuery(data) :\n            dataToQuery(data) ;\n    },\n\n    'multipart/form-data': function(data) {\n        // Mmmmmhmmm?\n        return data.get ?\n            data :\n            dataToFormData(data) ;\n    }\n});\n\nfunction formDataToJSON(formData) {\n    return JSON.stringify(\n        // formData.entries() is an iterator, not an array\n        Array\n        .from(formData.entries())\n        .reduce(function(output, entry) {\n            output[entry[0]] = entry[1];\n            return output;\n        }, {})\n    );\n}\n\nfunction formDataToQuery(data) {\n    return new URLSearchParams(data).toString();\n}\n\nfunction dataToQuery(data) {\n    return Object.keys(data).reduce((params, key) => {\n        params.append(key, data[key]);\n        return params;\n    }, new URLSearchParams());\n}\n\nfunction dataToFormData(data) {\n    throw new Error('TODO: dataToFormData(data)');\n}\n\nfunction urlFromData(url, data) {\n    // Form data\n    return data instanceof FormData ?\n        url + '?' + formDataToQuery(data) :\n        url + '?' + dataToQuery(data) ;\n}\n\nfunction createOptions(method, data, head, controller) {\n    const contentType = \n        typeof head === 'string' ? head :\n        head && head['Content-Type'] ||\n        'application/json' ;\n\n    const headers = createHeaders(contentType, assign(\n        config.headers && data ? config.headers(data) : {},\n        typeof head === 'string' ? {} : head\n    ));\n\n    const options = {\n        method:  method,\n        headers: headers,\n        credentials: 'same-origin',\n        signal: controller && controller.signal\n    };\n\n    if (method !== 'GET') {\n        options.body = createBody(contentType, config.body ? config.body(data) : data);\n    }\n\n    return options;\n}\n\nconst responders = {\n    'text/html': respondText,\n    'application/json': respondJSON,\n    'multipart/form-data': respondForm,\n    'application/x-www-form-urlencoded': respondForm,\n    'audio': respondBlob,\n    'audio/wav': respondBlob,\n    'audio/m4a': respondBlob\n};\n\nfunction respondBlob(response) {\n    return response.blob();\n}\n\nfunction respondJSON(response) {\n    return response.json().catch((e) => {\n        throw new Error('Cannot parse JSON ' + response.url + '. ' + e.message + '');\n    });\n}\n\nfunction respondForm(response) {\n    return response.formData();\n}\n\nfunction respondText(response) {\n    return response.text();\n}\n\nfunction respond(response) {\n    if (config.onresponse) {\n        response = config.onresponse(response);\n    }\n\n    if (!response.ok) {\n        throw new Error(response.statusText + '');\n    }\n\n    // Get mimetype from Content-Type, remembering to hoik off any\n    // parameters first\n    const mimetype = response.headers\n    .get('Content-Type')\n    .replace(/\\;.*$/, '');\n\n    return responders[mimetype](response);\n}\n\n\n/**\nrequest(method, url, data, mimetype | headers)\n\nUses `fetch()` to send a request to `url`. Where `type` is `\"GET\"`, `data` is\nserialised and appended to the URL, otherwise it is sent as a request body.\nThe 4th parameter may be a content type string or a headers object (in which\ncase it must have a `'Content-Type'` property).\n**/\n\nexport default function request(method = 'GET', url, data, contenttype = 'application/json') {\n    if (url.startsWith('application/') || url.startsWith('multipart/') || url.startsWith('text/') || url.startsWith('audio/')) {\n        throw new Error('request(method, url, data, contenttype) parameter order has changed. You passed (method, contenttype, url, data).');\n    }\n\n    method = method.toUpperCase();\n\n    // If this is a GET and there is data, append data to the URL query string\n    if (method === 'GET' && data) {\n        url = urlFromData(url, data);\n    }\n\n    // param[4] is an optional abort controller\n    const options = createOptions(method, data, contenttype, arguments[4]);\n    return fetch(url, options).then(respond);\n}\n\n/**\nrequestGet(url)\nA shortcut for `request('get', url, null, 'application/json')`\n**/\n\nexport function requestGet(url) {\n    return request('GET', url);\n}\n\n/**\nrequestPatch(url, data)\nA shortcut for `request('patch', 'application/json', url, data)`\n**/\n\nexport function requestPatch(url, data) {\n    return request('PATCH', url, data, 'application/json');\n}\n\n/**\nrequestPost(url, data)\nA shortcut for `request('post', 'application/json', url, data)`\n**/\n\nexport function requestPost(url, data) {\n    return request('POST', url, data, 'application/json');\n}\n\n/**\nrequestDelete(url, data)\nA shortcut for `request('delete', 'application/json', url, data)`\n**/\n\nexport function requestDelete(url, data) {\n    return request('DELETE', url, data, 'application/json');\n}\n\n/*\nthrottledRequest(type, mimetype, url)\n*/\n\nfunction ignoreAbortError(error) {\n    // Swallow AbortErrors, since we generate one every time we use\n    // the AbortController.\n    if (error.name === 'AbortError') {\n        console.log('Request aborted by throttle. Nothing to worry about.');\n\n        // JS promises have no machanism to conditionally catch different\n        // types of error – throw undefined to fall through to the next\n        // catch without a value.\n        throw undefined;\n    }\n\n    // Rethrow all other errors\n    throw error;\n}\n\nexport function throttledRequest(type, mimetype, url) {\n    var controller, data, promise;\n\n    function then() {\n        controller = undefined;\n    }\n\n    function send() {\n        controller = new AbortController();\n        var req = request(type, mimetype, url, data, controller);\n        req.then(then);\n        promise = undefined;\n        data    = undefined;\n        return req;\n    }\n\n    return function(object) {\n        data = object;\n\n        if (promise) {\n            return promise;\n        }\n\n        // Cancel previous request\n        if (controller) {\n            controller.abort();\n            controller = undefined;\n        }\n\n        // Batch requests to ticks\n        return promise = Promise\n        .resolve()\n        .then(send)\n        .catch(ignoreAbortError);\n    };\n}\n", "\n/**\nrequestData(url)\n\nTakes a `url` pointing to either a `.json` file, in which case it fetches and \nparses it, or a `.js` file, which it imports as a module, and returns a \npromise representing the result.\n\n```\nrequestData('./path/to/data.json');\n```\n\nWhere a `url` to a module is relative it is normalised to `window.location` so \nthat imports written in templates are treated relative to their location \n(dynamic `import()` would otherwise try and import relative to this \n`request.js` module).\n\n```\nrequestData('./path/to/module.js');\n```\n\nBy default a module request imports the default export. If `url` contains a \n`#fragment` identifier, the named export corresponding to the identifier is \nimported.\n\n```\nrequestData('./path/to/module#named');\n```\n\nIf the fragment identifier is also post-fixed with parameters then that named \nexport is treated as a constructor function and called:\n\n```\nrequestData('./path/to/module#named(\"parameter\")');\n```\n\nTo construct a default export use the name `default`:\n\n```\nrequestData('./path/to/module#default(\"parameter\")');\n```\n**/\n\nimport overload from '../../fn/modules/overload.js';\nimport cache from '../../fn/modules/cache.js';\nimport { requestGet } from '../../dom/modules/request.js';\n\nconst rextension = /\\.([\\w-]+)(?:#|\\?|$)/;\nconst rfragment  = /#(\\w+)(?:\\(([^\\)]*)\\))?$/;\nconst defaultexp = ['', 'default', ''];\nconst empty = [];\n\nexport default overload((url) => (rextension.exec(url) || empty)[1], {\n    js: (url) => {\n        // Rewrite relative import URLs to be absolute, taking the page as their\n        // relative root\n        const absolute = url[0] === '.' ?\n            new URL(url, window.location) :\n            url ;\n\n        // Otherwise use the export as data directly\n        return import(absolute).then((data) => data.default);\n    },\n\n    // Cache JSON requests in memory so that all requests to a given URL result \n    // in the same object.\n    default: cache((url) => requestGet(url))\n});\n", "/**\nfragmentFromHTML(html)\nReturns a DOM fragment of the parsed html `string`.\n*/\n\nexport default function fragmentFromHTML(html, tag) {\n    const range = document.createRange();\n\n    if (tag) {\n        const element = document.getElementsByTagName(tag).item(0);\n        // TODO: this will fail if there is no tag of this type already \n        // in the DOM\n        range.selectNode(element);\n    }\n\n    return range.createContextualFragment(html);\n}\n", "\n/**\ngetPath(path, object)\n\nReturns the value at `path` in `object`.\n\n```\nconst value = getPath('path.to.value', object);\n```\n*/\n\nimport curry from './curry.js';\n\nconst rpath = /\\.?([\\w-]+)/g;\n\nfunction getRegexPathThing(regex, path, object) {\n    var tokens = regex.exec(path);\n\n    if (!tokens) {\n        throw new Error('getPath(path, object): invalid path \"' + path + '\" at index ' + regex.lastIndex);\n    }\n\n    return getRegexPath(regex, path, object[tokens[1]]);\n}\n\nfunction getRegexPath(regex, path, object) {\n        // At the end of a path return what we've got there\n    return regex.lastIndex === path.length ? object :\n        // Otherwise where object is falsy further drilldown is not possoble\n        !object ? undefined :\n        // Otherwise drill down\n        getRegexPathThing(regex, path, object) ;\n}\n\nexport function getPath(path, object) {\n    rpath.lastIndex = 0;\n    return getRegexPath(rpath, path, object) ;\n}\n\nexport default curry(getPath, true);\n", "/**\nnoop()\nReturns undefined.\n*/\n\nexport default function noop() {}\n", "import noop from './noop.js';\n\nconst define = Object.defineProperties;\nconst freeze = Object.freeze;\n\nfunction self() {\n    return this;\n}\n\nexport default freeze(define([], {\n    // Make array and stream methods no-ops\n    shift:   { value: noop },\n    push:    { value: noop },\n    each:    { value: noop },\n    forEach: { value: noop },\n    start:   { value: noop },\n    stop:    { value: noop },\n    done:    { value: noop },\n    join:    { value: function() { return ''; } },\n    map:     { value: self },\n    filter:  { value: self },\n    reduce:  { value: function(fn, accumulator) { return accumulator; } }\n}));\n", "/**\nidentify(node)\n\nReturns the id of `node`, or where `node` has no id, a random id is generated,\nchecked against the DOM for uniqueness, set on `node` and returned:\n\n```\n// Get ids of all buttons in document\nselect('button', document)\n.map(identify)\n.forEach((id) => ...)\n```\n*/\n\nexport default function identify(node) {\n\tvar id = node.id;\n\n\tif (!id) {\n\t\tdo { id = Math.ceil(Math.random() * 100000); }\n\t\twhile (document.getElementById(id));\n\t\tnode.id = id;\n\t}\n\n\treturn id;\n}\n", "\n/**\nisTextNode(node)\nReturns `true` if `node` is a text node.\n**/\n\nexport default function isTextNode(node) {\n    return node.nodeType === 3;\n}\n", "\n/**\ntoType(node)\n\nReturns one of `'element'`, `'text'`, `'comment'`, `'document'`,\n`'doctype'` or `'fragment'`.\n**/\n\nvar types = {\n    1:  'element',\n    3:  'text',\n    8:  'comment',\n    9:  'document',\n    10: 'doctype',\n    11: 'fragment'\n};\n\nexport default function toType(node) {\n    return types[node.nodeType];\n}\n", "/**\nby(fn, a, b)\nCompares `fn(a)` against `fn(b)` and returns `-1`, `0` or `1`. Useful for sorting\nobjects by property:\n\n```\n[{id: '2'}, {id: '1'}].sort(by(get('id')));  // [{id: '1'}, {id: '2'}]\n```\n**/\n\nimport curry from './curry.js';\n\nexport function by(fn, a, b) {\n    const fna = fn(a);\n    const fnb = fn(b);\n    return fnb === fna ? 0 : fna > fnb ? 1 : -1 ;\n}\n\nexport default curry(by, true);\n", "/**\nexec(regex, fn, string)\n\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n*/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + string + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\n/**\nequals(a, b)\nPerform a deep equality comparison of `a` and `b`. Returns `true` if\nthey are equal.\n*/\n\nimport curry from './curry.js';\n\nexport function equals(a, b) {\n    // Fast out if references are for the same object\n    if (a === b) { return true; }\n\n    // If either of the values is null, or not an object, we already know\n    // they're not equal so get out of here\n    if (a === null ||\n        b === null ||\n        typeof a !== 'object' ||\n        typeof b !== 'object') {\n        return false;\n    }\n\n    // Compare their enumerable keys\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n\n    let n = akeys.length;\n    while (n--) {\n        // Has the property been set to undefined on a?\n        if (a[akeys[n]] === undefined) {\n            // We don't want to test if it is an own property of b, as\n            // undefined represents an absence of value\n            if (b[akeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // console.log(equals(a[akeys[n]], b[akeys[n]]), akeys[n], a[akeys[n]], b[akeys[n]]);\n            if (!b.hasOwnProperty(akeys[n]) || !equals(a[akeys[n]], b[akeys[n]])) {\n                return false;\n            }\n        }\n\n        const i = bkeys.indexOf(akeys[n]);\n        if (i > -1) {\n            bkeys.splice(i, 1);\n        }\n    }\n\n    n = bkeys.length;\n    while (n--) {\n        // Has the property been set to undefined on b?\n        if (b[bkeys[n]] === undefined) {\n            if (a[bkeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // We already know a does not have own property bkeys[n], because\n            // we have already been through all the enumerable properties\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport default curry(equals, true);\n", "/**\nmatches(selector, object)\nWhere `selector` is an object containing properties to be compared against\nproperties of `object`. If they are all strictly equal, returns `true`,\notherwise `false`.\n\n```\nconst vegeFoods = menu.filter(matches({ vegetarian: true }));\n```\n*/\n\nimport curry from './curry.js';\n\nexport function matches(object, item) {\n\tlet property;\n\tfor (property in object) {\n\t\tif (object[property] !== item[property]) { return false; }\n\t}\n\treturn true;\n}\n\nexport default curry(matches, true);\n", "/**\nslugify(string)\n\nReplaces any series of non-word characters with a `'-'` and lowercases the rest.\n\n```js\n    slugify('Party on #mydudes!') // 'party-on-mydudes'\n```\n**/\n\nexport default function slugify(string) {\n    // Accept a number or string\n    string = typeof string === 'number' ?\n        string + '' : \n        string.trim() ;\n\n    if (typeof string !== 'string') { return; }\n\n    return string\n    .toLowerCase()\n    .replace(/^[\\W_]+/, '')\n    .replace(/[\\W_]+$/, '')\n    .replace(/[\\W_]+/g, '-');\n}\n", "/**\nlast(array)\nGets the last value from an array.\n**/\n\nexport default function last(array) {\n    if (typeof array.length === 'number') {\n        return array[array.length - 1];\n    }\n\n    // Todo: handle Fns and Streams\n}\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default function toType(object) {\n    return typeof object;\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst value = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        throw new Error('Cannot parse px value');\n    }\n}, '36px');\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the \n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s\\d]*)\\s*$/;\n\nexport function parseValue(units, string) {\n    // Allow number to pass through\n    if (typeof string === 'number') {\n        return string;        \n    }\n\n    var entry = runit.exec(string);\n\n    if (!entry || !units[entry[2] || '']) {\n        if (!units.catch) {\n            throw new Error('Cannot parse value \"' + string + '\" with provided units ' + Object.keys(units).join(', '));\n        }\n\n        return entry ?\n            units.catch(parseFloat(entry[1]), entry[2]) :\n            units.catch(parseFloat(string)) ;\n    }\n\n    return units[entry[2] || ''](parseFloat(entry[1]));\n}\n\nexport default curry(parseValue);\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n\n    style('transform', node);            // returns transform\n\nIf `property` is of the form `\"property:name\"`, a named aspect of the property\nis returned.\n\n    style('transform:rotate', node);     // returns rotation, as a number, in radians\n    style('transform:scale', node);      // returns scale, as a number\n    style('transform:translateX', node); // returns translation, as a number, in px\n    style('transform:translateY', node); // returns translation, as a number, in px\n*/\n\nvar rpx          = /px$/;\nvar styleParsers = {\n\t\"transform:translateX\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[4]);\n\t},\n\n\t\"transform:translateY\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[5]);\n\t},\n\n\t\"transform:scale\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.sqrt(a * a + b * b);\n\t},\n\n\t\"transform:rotate\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.atan2(b, a);\n\t}\n};\n\nfunction valuesFromCssFn(string) {\n\treturn string.split('(')[1].split(')')[0].split(/\\s*,\\s*/);\n}\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    // If name corresponds to a custom property name in styleParsers...\n    if (styleParsers[name]) { return styleParsers[name](node); }\n\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' && rpx.test(value) ?\n        parseFloat(value) :\n        value ;\n}\n", "// Units\n\nimport id         from '../../fn/modules/id.js';\nimport overload   from '../../fn/modules/overload.js';\nimport toType     from '../../fn/modules/to-type.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet fontSize;\n\nfunction getFontSize() {\n    return fontSize ||\n        (fontSize = style(\"font-size\", document.documentElement));\n}\n\nwindow.addEventListener('resize', () => fontSize = undefined);\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`, \n`'100vw'` or `'100vh'`, and returns a numeric value in pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        em: function(n) {\n            return getFontSize() * n;\n        },\n\n        px: function(n) {\n            return n;\n        },\n\n        rem: function(n) {\n            return getFontSize() * n;\n        },\n\n        vw: function(n) {\n            return window.innerWidth * n / 100;\n        },\n\n        vh: function(n) {\n            return window.innerHeight * n / 100;\n        }\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns \na numeric value in `em`, eg. `0.625`. Depends on the `font-size` of the document \nroot at render time.\n*/\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns \na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the \ndocument root at render time.\n*/\n\nexport function rem(n) {\n    return px(n) / getFontSize();\n}\n\nexport const em = rem;\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a \nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at \nrender time.\n*/\n\nexport function vw(n) {\n    return (100 * px(n) / window.innerWidth);\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a \nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at \nrender time.\n*/\n\nexport function vh(n) {\n    return (100 * px(n) / window.innerHeight);\n}\n", "\n//const DEBUG = window.DEBUG === true;\n\nconst assign = Object.assign;\nconst define = Object.defineProperties;\nconst isExtensible = Object.isExtensible;\n\nexport const $observer = Symbol('observer');\n\nexport const analytics = {\n    observables: 0,\n    observes: 0\n};\n\nexport function remove(array, value) {\n    const i = array.indexOf(value);\n    if (i > -1) { array.splice(i, 1); }\n    return array;\n}\n\nexport function getTarget(object) {\n    return object && object[$observer] && object[$observer].target || object ;\n}\n\nexport function getObservables(key, target) {\n    const handlers    = target[$observer];\n    const observables = handlers.observables;\n    return observables[key] || (observables[key] = []);\n}\n\nexport function getMutationObservables(target) {\n    return target[$observer].sets || (target[$observer].sets = []);\n}\n\nfunction fire(fns, name, value) {\n    if (!fns || !fns.length) { return 0; }\n    fns = fns.slice(0);\n    var n = -1;\n\n    while (fns[++n]) {\n        // Observables are objects with a fn property\n        fns[n].fn(name, value);\n    }\n\n    return n;\n}\n\n/*\nnotify(object, path)\nForce the `object`'s Observer to register a mutation at `path`.\n*/\n\nexport function notify(path, object) {\n    const observer = object[$observer];\n    if (!observer) { return; }\n    const target = observer.target;\n    return fire(getObservables(path, target), target[path]);\n}\n\n\n// Observer proxy\n\nfunction isObservable(object) {\n    // Many built-in objects and DOM objects bork when calling their\n    // methods via a proxy. They should be considered not observable.\n    // I wish there were a way of whitelisting rather than\n    // blacklisting, but it would seem not.\n\n    return object\n        // Reject primitives and other frozen objects\n        // This is really slow...\n        //&& !isFrozen(object)\n        // I haven't compared this, but it's necessary for audio nodes\n        // at least, but then only because we're extending with symbols...\n        // hmmm, that may need to change...\n        && isExtensible(object)\n        // This is less safe but faster.\n        //&& typeof object === 'object'\n\n        // Reject DOM nodes\n        && !Node.prototype.isPrototypeOf(object)\n        // Reject WebAudio context\n        && (typeof BaseAudioContext === 'undefined' || !BaseAudioContext.prototype.isPrototypeOf(object))\n        // Reject dates\n        && !(object instanceof Date)\n        // Reject regex\n        && !(object instanceof RegExp)\n        // Reject maps\n        && !(object instanceof Map)\n        && !(object instanceof WeakMap)\n        // Reject sets\n        && !(object instanceof Set)\n        && !(window.WeakSet && object instanceof WeakSet)\n        // Reject TypedArrays and DataViews\n        && !ArrayBuffer.isView(object) ;\n}\n\n/*\nfunction trapGet(target, name, observer) {\n    let desc;\n        // If the property's not a symbol\n    return typeof name !== 'symbol'\n        // and it's writable\n        && ((desc = Object.getOwnPropertyDescriptor(target, name)), !desc || desc.writable)\n        // return the observer of its value\n        && Observer(target[name])\n        // otherwise the value\n        || target[name] ;\n}\n\nconst arrayHandlers = {\n    get: trapGet,\n\n    set: function(target, name, value, receiver) {\n        // We are setting a symbol\n        if (typeof name === 'symbol') {\n            target[name] = value;\n            return true;\n        }\n\n        var old = target[name];\n        var length = target.length;\n\n        // If we are setting the same value, we're not really setting at all\n        if (old === value) { return true; }\n\n        var properties = target[$data].properties;\n        var change;\n\n        // We are setting length\n        if (name === 'length') {\n            if (value >= target.length) {\n                // Don't allow array length to grow like this\n                target.length = value;\n                return true;\n            }\n\n            change = {\n                index:   value,\n                removed: A.splice.call(target, value),\n                added:   nothing,\n            };\n\n            while (--old >= value) {\n                fire(properties[old], undefined);\n            }\n        }\n\n        // We are setting an integer string or number\n        else if (+name % 1 === 0) {\n            name = +name;\n\n            if (value === undefined) {\n                if (name < target.length) {\n                    change = {\n                        index:   name,\n                        removed: A.splice.call(target, name, 1),\n                        added:   nothing\n                    };\n\n                    value = target[name];\n                }\n                else {\n                    return true;\n                }\n            }\n            else {\n                change = {\n                    index:   name,\n                    removed: A.splice.call(target, name, 1, value),\n                    added:   [value]\n                };\n            }\n        }\n\n        // We are setting some other key\n        else {\n            target[name] = value;\n        }\n\n        if (target.length !== length) {\n            fire(properties.length, target.length);\n        }\n\n        // Notify the observer\n        fire(properties[name], Observer(value) || value);\n\n        var mutate = target[$data].mutate;\n        fire(mutate, receiver, change);\n\n        // Return true to indicate success\n        return true;\n    }\n};\n*/\n\n/** \nObjectTrap()\n**/\n\nconst properties = {\n    [$observer]: {}\n};\n\nfunction ObjectTrap() {\n    this.observables = {};\n    this.gets = [];\n    this.sets = undefined;\n}\n\nassign(ObjectTrap.prototype, {\n    // Inside handlers, observer is the observer proxy or an object that \n    // inherits from it\n    get: function get(target, name, proxy) {\n        const value = target[name];\n\n        // Don't observe changes to symbol properties, and\n        // don't allow Safari to log __proto__ as a Proxy. (That's dangerous!\n        // It pollutes Object.prototpye with [$observer] which breaks everything.)\n        // Also, we're not interested in observing the prototype chain so\n        // stick to hasOwnProperty.\n        if (typeof name === 'symbol' || name === '__proto__') {\n            return value;\n        }\n\n        // Is the property mutable? Note that unset properties have no descriptor\n        const descriptor = Object.getOwnPropertyDescriptor(target, name);\n        const mutable    = descriptor ?\n            descriptor.writable || descriptor.set :\n            value === undefined ;\n\n        if (mutable) {\n            fire(this.gets, name);\n        }\n\n        // Get the observer of its value\n        const observer = Observer(value); \n        \n        if (!observer) {\n            return value;\n        }\n\n        // If get operations are being monitored, make them monitor the\n        // object at the named key also\n        var n = -1;\n        while(this.gets[++n]) {\n            this.gets[n].listen(name);\n        }\n\n        return observer;\n    },\n    \n    set: function set(target, name, value, proxy) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            target[name] = value;\n            return true;\n        }\n\n        // If we are setting the same value, we're not really setting at all\n        if (target[name] === value) {\n            return true;\n        }\n\n        var n = -1;\n        while(this.gets[++n]) {\n            this.gets[n].unlisten(name);\n        }\n\n        // Set the target of value on target. Then use that as value just \n        // in case target is doing something funky with property descriptors\n        // that return a different value from the value that was set. Rare,\n        // but it can happen.\n        target[name] = getTarget(value);\n        value = target[name];\n\n        fire(this.observables[name], value);\n        fire(this.sets, value);\n\n        // Return true to indicate success to Proxy\n        return true;\n    },\n    \n    deleteProperty: function(target, name) {\n        if (typeof name === 'symbol' || name === '__proto__') {\n            // Delete without notifying\n            delete target[name];\n            return true;\n        }\n\n        if (!target.hasOwnProperty(name)) {\n            // Nothing to delete\n            return true;\n        }\n\n        delete target[name];\n\n        const observables = this.observables[name]; \n        if (observables) {\n            fire(observables, target[name]);\n        }\n        \n        // Indicate success to the Proxy\n        return true;\n    }\n});\n\nfunction createObserver(target) {\n    const traps    = new ObjectTrap();\n    const observer = new Proxy(target, traps);\n\n    traps.observer = observer;\n    traps.target   = target;\n\n    properties[$observer].value = traps;\n    define(target, properties);\n    return observer;\n}\n\n\n/**\nObserver(object)\nCreate an observer proxy around `object`. Mutations made to this proxy are \nobservable via `observe(path, object` and `mutations(paths, object)`.\n**/\n\nexport function Observer(object) {\n    return !object ? undefined :\n        (object[$observer] && object[$observer].observer || (isObservable(object) ?\n            createObserver(object) :\n            undefined\n        ));\n}\n\n", "\nimport id      from '../modules/id.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\nconst define = Object.defineProperties;\n\n\n/**\nStream()\n**/\n\nconst properties = {\n    source:    { writable: true },\n    consumer:  { writable: true }\n};\n\n\nfunction stopOne(stopable) {\n    return stopable.stop ?\n        stopable.stop() : \n        stopable() ;\n}\n\nfunction stopAll(stopables) {\n    stopables.forEach(stopOne);\n    stopables.length = 0;\n}\n\nfunction push() {\n    const length = arguments.length;\n    let n = -1;\n    while (++n < length) {\n        this.consumer.push(arguments[n]);\n    }\n    return this;\n}\n\nfunction stop() {\n    this.stopables && stopAll(this.stopables);\n    //this.consumer = undefined;\n    return this;\n    //throw new Error('TODO: Implement stream mouth stop()');\n}\n\nfunction done(fn) {\n    const stopables = this.stopables || (this.stopables = []);\n    stopables.push(fn);\n    return;\n}\n\nconst sourceProps = {\n    push: { value: push },\n    stop: { value: stop }\n};\n\n\n\n/*\nfunction Source(stream, start) {\n    this.stream  = stream;\n    this.startFn = start;\n}\n\nassign(Source.prototype, {\n    push: function push() {\n        const length = arguments.length;\n        let n = -1;\n        while (++n < length) {\n            this.stream.consumer.push(arguments[n]);\n        }\n        return this;\n    },\n\n    start: function() {\n        const start = this.startFn;\n        //const source = create(this, sourceProps);\n        // Assign push(), stop() if they are returned\n        assign(this.stream, start(this));\n        return this;\n    },\n\n    stop: stop,\n    done: done\n});\n*/\nexport default function Stream(start) {\n    // Support construction without `new`\n    if (!Stream.prototype.isPrototypeOf(this)) {\n        return new Stream(start);\n    }\n\n    this.start = function() {\n        const source = create(this, sourceProps);\n        // Assign push(), stop() if they are returned\n        assign(this, start(source));\n        return this;\n    };\n\n    this.stop   = stop;\n    this.done   = done;\n    this.source = this;\n    //this.source = new Source(this, start);\n}\n\nassign(Stream, {\n    /**\n    Stream.from(values)\n    **/\n    from: function(values) {\n        return new Stream((controller) => controller.push.apply(controller, values));\n    },\n\n    /**\n    Stream.of(value1, value2, ...)\n    **/\n    of: function() {\n        return this.from(arguments);\n    }\n});\n\nassign(Stream.prototype, {\n    /** \n    .map()\n    **/\n    map: function(fn) {\n        return this.consumer = new Map(this.source, fn);\n    },\n\n    /** \n    .filter()\n    **/\n    filter: function(fn) {\n        return this.consumer = new Filter(this.source, fn);\n    },\n\n    /** \n    .reduce()\n    Consumes the stream, returns a promise of the accumulated value.\n    **/\n    reduce: function(fn, accumulator) {\n        return this.pipe(new Reduce(this.source, fn, accumulator));\n    },\n\n    /** \n    .scan()\n    **/\n    scan: function(fn, accumulator) {\n        return this.consumer = new Scan(this.source, fn, accumulator);\n    },\n    \n    /** \n    .take()\n    **/\n    take: function(n) {\n        return this.consumer = new Take(this.source, n);\n    },\n    \n    /** \n    .each()\n    **/\n    each: function(fn) {\n        return this.pipe(new Each(this.source, fn));\n    },\n    \n    /** \n    .pipe()\n    **/\n    pipe: function(consumer) {\n        //consumer.done && consumer.done(this);\n        this.consumer = consumer;\n        this.start();\n        return this.consumer;\n    },\n\n    /** \n    .done()\n    **/\n    done: function(fn) {\n        this.source.done(fn);\n        return this;\n    },\n\n    /** \n    .start()\n    **/\n    start: function() {\n        this.source.start();\n        return this;\n    },\n\n    /** \n    .stop()\n    **/\n    stop: function() {\n        this.source.stop();\n        return this;\n    }\n});\n\n\n/*\nMap()\n*/\n\nconst mapProperties = assign({ fn: { value: id }}, properties);\n\nfunction Map(source, fn) {\n    mapProperties.source.value = source;\n    mapProperties.fn.value = fn;\n    define(this, mapProperties);\n}\n\nMap.prototype = create(Stream.prototype);\n\nMap.prototype.push = function map(value) {\n    if (value !== undefined) {\n        this.consumer.push(this.fn(value));\n    }\n    return this;\n};\n\n\n/*\nFilter()\n*/\n\nfunction Filter(source, fn) {\n    mapProperties.source.value = source;\n    mapProperties.fn.value = fn;\n    define(this, mapProperties);\n}\n\nFilter.prototype = create(Stream.prototype);\n\nFilter.prototype.push = function filter(value) {\n    if (value !== undefined && this.fn(value)) {\n        this.consumer.push(value);\n    }\n\n    return this;\n};\n\n\n/*\nTake()\n*/\n\nconst takeProperties = assign({ n: { value: 0 }}, properties);\n\nfunction Take(source, n) {\n    if (typeof n !== 'number' || n < 1) {\n        throw new Error('stream.take(n) accepts non-zero positive integers as n (' + n + ')');\n    }\n\n    takeProperties.source.value = source;\n    takeProperties.n.value = n;\n    define(this, takeProperties);\n}\n\nTake.prototype = create(Stream.prototype);\n\nTake.prototype.push = function take(value) {\n    this.consumer.push(value);\n\n    if (!(--this.n)) {\n        // Stream is dead TODO stop only downstream objects\n        this.stop();\n    }\n\n    return this;\n};\n\n\n/*\nReduce()\n*/\n\nconst reduceProperties = assign({\n    value: { writable: true }\n}, mapProperties);\n\nfunction Reduce(source, fn, accumulator) {\n    reduceProperties.source.value = source;\n    reduceProperties.fn.value = fn;\n    reduceProperties.value.value = accumulator;\n    define(this, reduceProperties);\n}\n\nReduce.prototype = create(Stream.prototype);\n\nReduce.prototype.push = function reduce(value) {\n    if (value !== undefined) {\n        this.value = this.fn(this.value, value);\n    }\n\n    return new Promise((resolve, reject) => {\n        this.done(() => resolve(this.value));\n    });\n};\n\n\n/*\nScan()\n*/\n\nfunction Scan(source, fn, accumulator) {\n    reduceProperties.source.value = source;\n    reduceProperties.fn.value = fn;\n    reduceProperties.value.value = accumulator;\n    define(this, reduceProperties);\n}\n\nScan.prototype = create(Stream.prototype);\n\nScan.prototype.push = function scan(value) {\n    if (value !== undefined) {\n        this.value = this.fn(this.value, value);\n        this.consumer.push(this.value);\n    }\n\n    return this;\n};\n\n\n/*\nEach()\n*/\n\nconst eachProperties = {\n    source: { writable: true }\n};\n\nfunction Each(source, fn) {\n    eachProperties.source.value = source;\n    define(this, eachProperties);\n    this.push = fn;\n}\n\nEach.prototype = create(Stream.prototype, {\n    // Can't consume a consumed stream\n    each: { value: null },\n    pipe: { value: null }\n});\n", "/** \nObserve()\nAn object whose fn is called by the proxy traps set and delete when a value\nchanges. This object is internal-only.\n\n```\n.path   - full observable path\n.index  - index of path consumed\n.target - observer target object\n.key    - last parsed key from path\n```\n\n**/\n\nimport Stream from '../stream/stream.js';\nimport { Observer, analytics, remove, getObservables, getMutationObservables } from './observer.js';\n\nconst assign = Object.assign;\n\nconst rkey = /(^\\.?|\\.)\\s*([\\w-]*)\\s*/g;\n\nfunction Observe(path, index, target, output) {\n    if (!path.length) {\n        throw new Error('Path is empty!');\n    }\n\n    // Parse path\n    rkey.lastIndex = index;\n    const r = rkey.exec(path);\n\n    // Check that path is valid\n    if (!r) {\n        throw new Error('Cant parse path ' + this.path + ' at index ' + this.index);\n    }\n\n    this.target = target;\n    this.path   = path;\n    this.index  = rkey.lastIndex;\n    this.output = output;\n    \n    // Are we at the end of the path?\n    if (this.index >= this.path.length) {\n        this.fn = this.output;\n    }\n\n    if (!r[2]) {\n        // Check that if there is no key we are being instructed to observe all \n        // mutations with a '.' at the end of path (TODO)\n        if (r[1] !== '.') {\n            throw new Error('Path must end with \".\" (', r[1], path, ') Todo: observe all mutations');\n        }\n\n        this.key = '.';    \n        this.listen();\n        this.fn(this.target);\n    }\n    else {\n        this.key    = r[2];\n        this.listen();    \n        this.fn(this.target[this.key]);\n    }\n\n    if (window.DEBUG) { ++analytics.observes; }\n}\n\nassign(Observe.prototype, {\n    fn: function(value) {\n        const type = typeof value;\n\n        // We already know that we are not at path end here, as this.fn is \n        // replaced with a consumer at path end (in the constructor).\n\n        // If the value is immutable we have no business observing it\n        if (!value || (type !== 'object' && type !== 'function')) {\n            if (this.child) {\n                this.child.stop();\n                this.child = undefined;\n            }\n\n            // We are not at path end, and have just received an object that\n            // cannot have deep properties, so value must be undefined\n            this.output(undefined);\n            return;\n        }\n\n        if (this.child) {\n            this.child.unlisten();\n            this.child.target = value;\n            this.child.listen();\n            //this.child.fn(value);\n        }\n        else {\n            this.child = new Observe(this.path, this.index, value, this.output);\n        }\n\n        // If this.child.key is '.' we have a problem\n        if (this.child.key === '.') {\n            throw new Error('Arrrrgh');\n        }\n\n        this.child.fn(value[this.child.key]);\n    },\n\n    listen: function() {\n        const observer = Observer(this.target);\n\n        if (!observer) {\n            if (window.DEBUG) {\n                console.log('CANNOT LISTEN TO UNOBSERVABLE', this.target);\n            }\n\n            return;\n        }\n\n        const observables = this.key === '.' ?\n            getMutationObservables(this.target) :\n            getObservables(this.key, this.target) ;\n\n        if (observables.includes(this)) {\n            throw new Error('observe.listen this is already bound');\n        }\n\n        observables.push(this);\n    },\n\n    unlisten: function() {\n        const observables = this.key === '.' ?\n            getMutationObservables(this.target) :\n            getObservables(this.key, this.target) ;\n\n        remove(observables, this);\n    },\n\n    stop: function() {\n        this.unlisten();\n        this.child && this.child.stop();\n        this.child = undefined;\n        if (window.DEBUG) { --analytics.observes; }\n    }\n});\n\n\n/**\nObservable(path, target, currentValue)\n**/\n\nexport default function Observable(path, target, current) {\n    return new Stream((stream) => {\n        const observe = new Observe(path, 0, target, (value) => {\n            if (value === current) { return; }\n            current = value;\n            stream.push(value);\n        });\n        \n        return {\n            stop: () => observe.stop()\n        };\n    });\n}\n", "\nimport Stream from './stream.js';\n\nconst assign = Object.assign;\n\nexport function Combine(streams) {\n    return new Stream((controller) => {\n        const values = {};\n        let i = -1, stream;\n        while (stream = streams[++i]) {\n            const n = i;\n            stream.each((value) => {\n                values[n] = value;\n                controller.push(assign({}, values));\n            });\n        }\n    });\n}\n\nexport default function combine() {\n    return Combine(arguments);\n}\n", "\nimport { getTarget } from './observer.js';\nimport Observable    from './observable.js';\nimport { Combine }   from '../stream/combine.js';\n\n\n/**\nobserve(path, target)\nReturns an Observable of a dot-notation `path` in `target`, with the methods:\n\n```\n.each(fn)\n.pipe(pushable)\n.stop()\n```\n\nMay also be called with an `initial` value. Where the value at `path` of `target`\nis not strictly equal to `initial`, the consumer will be called (synchronously) \nwhen attached.\n\n```\nobserve(path, target, initial)\n.each(fn)\n```\n**/\n\nexport default function(path, object, initial) {\n    return new Observable(path, getTarget(object), initial);\n}\n\n/**\nobserve(paths, target)\nReturns an Observable of a dot-notation `path` in `target`, with the methods:\n\n```\n.each(fn)\n.pipe(pushable)\n.stop()\n```\n\nMay also be called with an `initial` value. Where the value at `path` of `target`\nis not strictly equal to `initial`, the consumer will be called (synchronously) \nwhen attached.\n\n```\nobserve(paths, target, initial)\n.each(fn)\n```\n**/\n\nexport function observe(paths, object) {\n    paths = typeof paths === 'string' ? paths.split(/\\s+/) : paths ;\n\n    const target      = getTarget(object);\n    const observables = paths.map((path, i) => new Observable(path, target, arguments[i + 2]));\n\n    return observables.length > 1 ?\n        new Combine(observables) :\n        observables[0] ;\n}\n", "\n/** \nmerge(source1, source2, ...)\nMerges multiple sources into a hot stream.\n**/\n\nimport Stream from './stream.js';\n\nexport function Merge(streams) {\n    return new Stream((controller) => {\n        let i = -1, stream;\n        while (stream = streams[++i]) {\n            if (stream.each) {\n                // Merge streams\n                stream.each((value) => controller.push(value));\n                // And stop them when this one stops?\n                controller.done(stream);\n            }\n            else {\n                // Merge arrays or array-likes\n                controller.push.apply(controller, stream);\n            }\n        }\n    });\n}\n\nexport default function merge() {\n    return Merge(arguments);\n}\n", "\nimport Stream from './stream.js';\n\nconst A = Array.prototype;\n\nfunction hasLength(buffer) {\n    return buffer.length > 0;\n}\n\nfunction toObject(object, buffer, i) {\n    object[i] = buffer.shift();\n    return object;\n}\n\nfunction makeArray(object) {\n    return [];\n}\n\nexport function Zip(streams) {\n    const buffers = A.map.call(streams, makeArray);\n\n    return new Stream((controller) => {\n        A.forEach.call(streams, (stream, i) => {\n            const buffer = buffers[i];\n\n            if (stream.each) {\n                // Support streams\n                controller.done(\n                    stream.each((value) => {\n                        buffer.push(value);\n                        if (buffers.every(hasLength)) {\n                            controller.push(buffers.reduce(toObject, {}));\n                        }\n                    })\n                );\n            }\n            // Support array-likes\n            else {\n                A.forEach.call(stream, (value) => {\n                    buffer.push(value);\n                    if (buffers.every(hasLength)) {\n                        controller.push(buffers.reduce(toObject, {}));\n                    }\n                });\n            }\n        });\n    });\n}\n\nexport default function zip() {\n    return Zip(arguments);\n}\n", "\n/**\nTemplate functions\n\nThe scope of literal templates contains a small library of functions. Some are \nsimply JS built-ins aliased for brevity. Others provide template includes, \nrouting and value transformations.\n\n**/\n\nimport id              from '../../fn/modules/id.js';\nimport by              from '../../fn/modules/by.js';\nimport capture         from '../../fn/modules/capture.js';\nimport equals          from '../../fn/modules/equals.js';\nimport matches         from '../../fn/modules/matches.js';\nimport nothing         from '../../fn/modules/nothing.js';\nimport get             from '../../fn/modules/get-path.js';\nimport noop            from '../../fn/modules/noop.js';\nimport slugify         from '../../fn/modules/slugify.js';\nimport last            from '../../fn/modules/last.js';\nimport overload        from '../../fn/modules/overload.js';\nimport { px, em, rem, vw, vh } from '../../dom/modules/parse-length.js';\nimport { Observer }    from '../../fn/observer/observer.js';\nimport { observe }     from '../../fn/observer/observe.js';\nimport Stream          from '../../fn/stream/stream.js';\nimport combine         from '../../fn/stream/combine.js';\nimport merge           from '../../fn/stream/merge.js';\nimport zip             from '../../fn/stream/zip.js';\nimport print           from '../library/print.js';\n\nconst assign  = Object.assign;\nconst entries = Object.entries;\n\nconst library = {\n    /** assign(a, b, ...)\n    Alias of `Object.assign()`.\n    **/\n    assign: assign,\n    \n    /** by(fn, a, b)\n    Compares `fn(a)` against `fn(b)` and returns `-1`, `0` or `1`. Partially \n    applicable and intended for use in `array.sort()`. For example, to sort an\n    array of objects by their ids:\n\n    ```\n    array.sort(by(get('id')))\n    ```\n    **/\n    by,\n\n    /** \n    capture()\n    **/\n    capture: capture,\n\n    /** \n    combine(source1, source2, ...)\n    Combines multiple sources into a single stream.\n    **/\n    combine: combine,\n\n    /** ceil(n)\n    Alias of `Math.ceil()`.\n    **/\n    ceil: Math.ceil,\n\n    /** define()\n    Alias of `Object.defineProperties()`.\n    **/\n    define: Object.defineProperties,\n    \n    /** entries(object)\n    Alias of `Object.entries()`.\n    **/\n    entries: entries,\n\n    /** equals(a, b)\n    Compares `a` and `b` for deep equality and returns `true` or `false`.\n    **/\n    equals,\n\n    /** floor(n)\n    Alias of `Math.floor()`.\n    **/\n    floor: Math.floor,\n\n    /** get(path, object)\n    Gets the value of `path` in `object`, where `path` is a string in JS \n    dot-notation. Where a path does not lead to a value, returns `undefined`:\n    \n    ```\n    get('path.to.value', {})       // undefined\n    ```\n\n    Numbers are accepted as path components:\n\n    ```\n    get('array.0', {\n        array: ['first', 'second']\n    })                             // 'first'\n    ```\n    **/\n    get,\n    \n    /** id(object)\n    Returns `object`.\n    **/\n    id,\n    \n    /** keys(object)\n    Alias of `Object.keys()`.\n    **/\n    keys: Object.keys,\n    \n    /** last()\n    Gets the last item from an array or array-like.\n    **/\n    last,\n    \n    /** matches(selector, object)\n    Returns true where all the properties of `selector` are strictly equal to the \n    same properties of `object`.\n    **/\n    matches,\n\n    /** \n    merge(source1, source2, ...)\n    Merges multiple sources into a single stream.\n    **/\n    merge,\n    \n    /** \n    zip(source1, source2, ...)\n    Zips multiple sources into a single stream of array.\n    **/\n    zip,\n\n    /** noop()\n    Return undefined.\n    **/\n    noop,\n    \n    /* \n    nothing\n    A frozen array representing no value.\n    */\n    //nothing,\n    \n    /** observe(path, object)\n    Returns an observable of mutations to `path` in `object`. Consume mutations\n    with an observable's `.each()` method.\n\n    ```js\n    const observable = observe('title', data).each((title) => console.log(title));\n    ```\n\n    Observables may be stopped with the method `.stop()`:\n\n    ```js\n    observable.stop();\n    ```\n\n    Renderers (which are exposed as `this` inside templates), have a `.done()` \n    method that calls a subscriber's `.stop()` method when the render is \n    stopped. This pattern observes `data.title` until the next render:\n\n    ```js\n    this.done(observe('title', data).each((title) => console.log(title)));\n    ```\n    **/\n    observe,\n\n    /* Observer(object)\n    Returns the Observer proxy of `object`. Use this proxy to make changes to \n    an object that may be observed using `observe(path, object)` (above).\n    */\n    Observer,\n\n    /* overload(fn, object) */\n    overload,\n    \n    print: window.DEBUG ? print : noop,\n\n    /** round(n)\n    Alias of `Math.round()`;\n    **/\n    round: Math.round,\n\n    /** \n    paramify(object)\n    Turns an object with enumerable properties into a search parameters object\n    (which stringifies to a search parameter string).\n    **/\n    paramify: function(object) {\n        // If this is an object with properties that may be arrays, flatten it\n        // out into entries\n        const params = typeof object === 'object' && typeof object.length !== 'number' ?        \n            entries(object).flatMap((entry) => (\n                entry[1] === undefined ? nothing :\n                entry[1] && typeof entry[1] === 'object' && entry[1].map ? entry[1].map((value) => [entry[0], value]) : \n                [entry]\n            )) :\n            object ;\n\n        //console.log('PARAMIFY', object, params);\n        return new URLSearchParams(params);\n    },\n\n    /** slugify(string)\n    Returns the slug of `string`.\n    **/\n    slugify,\n    \n    /** Stream(fn)\n    Returns a stream of values.\n    **/\n    Stream,\n\n    /** \n    translate()\n    **/\n    translate: function(key) {\n        return window.translations && window.translations[key] || key;\n    },\n\n    /** values()\n    Alias of `Object.values()`.\n    **/\n    values: Object.values,\n\n    px,\n    em,\n    rem,\n    vw,\n    vh\n};\n\nexport default library;\n\nexport function register(name, fn) {\n    if (library[name]) {\n        throw new Error('Literal: function \"' + name + '\" already registered');\n    }\n\n    library[name] = fn;\n\n    // Allow registered fns to be exported directly from their modules via\n    // `export default register(name, fn);` by returning `fn`.\n    return fn;\n}\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "\n/** \ncompile(scope, paramString, code, context)\n\nCompiles a new function from `code` that runs in `scope` with the arguments \nlisted in `paramString`. If a `context` is passed in, you get an arrow function,\notherwise a normal function (leaving you the possibility to set the context at \nruntime with `fn.apply(context, params)`).\n**/\n\nimport get from './get.js';\n\nfunction isValidConst(namevalue) {\n    const name = namevalue[0];\n    return /^\\w/.test(name);\n}\n\nexport default function compile(scope = {}, paramString, code, context) {\n    const entries = Object.entries(scope).filter(isValidConst);\n    const keys    = entries.map(get(0));\n    const values  = entries.map(get(1));\n\n    return context ?\n        // The arrow function has it's context set\n        new Function(...keys, 'return (' + paramString + ') => {' + (code || '') + '}')\n        .apply(context, values) :\n        // This function can be called with a context fn.call(context, data)\n        new Function(...keys, 'return function(' + paramString + '){' + (code || '') + '}')\n        .apply(null, values) ;\n}\n", "\nexport default {\n    Totals: {\n        template:  0,\n        text:      0,\n        attribute: 0,\n        boolean:   0,\n        class:     0,\n        checked:   0,\n        value:     0\n    }\n};\n\nexport const meta = {\n    count: 0\n};\n", "\nimport compileFn from '../../fn/modules/compile.js';\nimport analytics from './renderers/analytics.js';\n\nif (window.DEBUG) {\n    analytics.totalCompileTime = 0;\n}\n\n/**\ncompile(scope, params, source, id, info, element)\nCompiles a literal template to a function.\n**/\n\nconst indent = '  ';\n\n// Store render functions against their source\nexport const cache = {};\n\n// Last two params, info and element, are purely for debug messages\nexport default function compile(scope, params, source, id, info, element) {\n    if (typeof source !== 'string') {\n        throw new Error('Template is not a string');\n    }\n\n    const key = id || source;\n\n    // Return cached fn\n    if (cache[key]) { return cache[key]; }\n\n    const code = '\\n'\n        + (id ? indent + '// Template #' + id + '\\n' : '')\n        + indent + 'return this.resolve`' + source + '`;\\n';\n\n    if (window.DEBUG) {\n        try {\n            const text = source.trim();\n            const name = text.length > 32 ?\n                text.slice(0, 30).replace(/\\s+/g, ' ').replace('\"', '\\\\\"') + ' …' :\n                text.replace(/\\s+/g, ' ').replace('\"', '\\\\\"') ;\n\n            const t0 = window.performance.now();\n            cache[key] = compileFn(scope, params, \n                'try {' + code + '} catch(e) {' +\n                // Append useful info to error message\n                indent + 'e.message += \" in template #\" + this.template + (this.element && this.element.tagName ? \", <\" + this.element.tagName.toLowerCase() + (this.name ? \" \" + this.name + \"=\\\\\"' + name + '\\\\\">\" : \"> ' + name + '\") : \"\");' +\n                indent + 'throw e;' +\n                '}'\n            );\n\n            const t1 = window.performance.now();\n            analytics.totalCompileTime += (t1 - t0);\n\n            // timeEnd(name);\n            return cache[key];\n        }\n        catch(e) {\n            // Append useful info to error message\n            e.message += ' in template #' + info.template + (element && element.tagName ? ', <' + element.tagName.toLowerCase() + (info.name ? ' ' + info.name + '=\"' + source + '\">' : '>') : '') ;\n            throw e;\n        }\n    }\n\n    return cache[key] = compileFn(scope, params, code);\n}\n", "\nimport Stream from '../stream/stream.js';\nimport { remove, getTarget, $observer } from './observer.js';\n\n//const DEBUG = window.DEBUG === true;\n\nconst assign = Object.assign;\nconst values = Object.values;\n\n/** \nreads(object)\nCalls `fn` for every property of `object` read via a get operation. Returns an\nobject with the method `.stop()`.\n**/\n\nfunction stop(gets) {\n    gets.stop();\n}\n\nfunction Gets(target, path, root) {\n    this.children = {};\n\n    // For some reason child proxies are being set... dunno how...\n    this.target = getTarget(target);\n    this.path   = path;\n    this.root   = root;\n\n    target[$observer].gets.push(this);\n}\n\nassign(Gets.prototype, {\n    listen: function(key) {\n        // We may only create one child observer per key\n        if (this.children[key]) { return; }\n        const path = this.path ? this.path + '.' : '';\n        this.children[key] = new Gets(this.target[key], path + key, this.root);\n    },\n\n    unlisten: function(key) {\n        // Can't unobserve the unobserved\n        if (!this.children[key]) { return; }\n        this.children[key].stop();\n        delete this.children[key];\n    },\n\n    // Named fn because that is what is called by Observer's ObjectTrap\n    fn: function(key) {\n        const path = this.path ? this.path + '.' : '';\n        // Pass concatenated path to parent fn\n        this.root.push(path + key);\n    },\n\n    stop: function() {\n        remove(this.target[$observer].gets, this);\n        values(this.children).forEach(stop);\n    }\n});\n\nexport default function reads(observer) {\n    return new Stream((controller) => {\n        controller.done(new Gets(getTarget(observer), '', controller))\n        return;\n    });\n}\n", "\nimport { log, group, groupEnd } from '../log.js';\nimport analytics from './analytics.js';\nimport { cache as compileCache } from '../compile.js';\n\nconst renderers = [];\nconst promise   = Promise.resolve(renderers);\n\nconst logs = window.DEBUG && {\n    totalCompileTime: 0,\n    totalCompileCount: 0\n};\n\nlet cued;\n\nfunction constructorCount(renderers) {\n    // Count constructors\n    return renderers\n    .map((renderer) => renderer.constructor.name.replace('Renderer', ''))\n    .reduce((names, name) => {\n        const i = names.indexOf(name);\n        if (i === -1) { names.push(1, name); }\n        else          { ++names[i - 1]; }\n        return names;\n    }, [])\n    .reduce((string, value) => string + (\n        typeof value === 'number' ?\n            string ? ', ' + value :\n            value :\n        ' ' + value\n    ), '');\n}\n\nfunction render(renderers) {\n    if (window.DEBUG) {\n        var t0 = window.performance.now() / 1000;\n        group('batch', t0.toFixed(3) + ' – cued ' + constructorCount(renderers), '#B6BD00');\n        var ids = {};\n    }\n\n    var renderer, count = 0;\n    while (renderer = renderers.shift()) {\n        // Call .update() with latest arguments\n        count += renderer.update.apply(renderer, renderer.cuedArguments);\n        renderer.cuedArguments = undefined;\n        renderer.cued = false;\n        if (window.DEBUG) {\n            ids && (ids[renderer.id] = ids[renderer.id] === undefined ? 1 : ids[renderer.id] + 1);\n        }\n    }\n\n    cued = undefined;\n\n    if (window.DEBUG) {\n        const keys = Object.keys(ids);\n        const t1 = window.performance.now() / 1000;\n\n        if (logs.totalCompileTime !== analytics.totalCompileTime) {\n            logs.batchCompileTime = analytics.totalCompileTime - logs.totalCompileTime;\n            logs.totalCompileTime = analytics.totalCompileTime;\n            const totalCompileCount = Object.keys(compileCache).length;\n            logs.batchCompileCount = totalCompileCount - logs.totalCompileCount;\n            logs.totalCompileCount = totalCompileCount;\n            log('compile', logs.batchCompileCount + ' literal' + (logs.batchCompileCount === 1 ? '' : 's') + ', ' + logs.batchCompileTime.toPrecision(3) + 'ms', ' total', totalCompileCount + ' literals, ' + (logs.totalCompileTime).toPrecision(3) + 'ms', '#DDB523');\n        }\n        else {\n            logs.batchCompileTime = 0;\n        }\n\n        log('render',\n            // renderers\n            keys.length + ' renderer' + (keys.length === 1 ? ', ' : 's, ')\n            // mutations\n            + count + ' mutation' + (count === 1 ? ', ' : 's, ') \n            // duration\n            + ((t1 - t0) * 1000 - logs.batchCompileTime).toPrecision(3) + 'ms' \n            // ids\n            + ' (' + keys.slice(0, 12).join(', ') + (keys.length > 12 ? ', ...)' : ')'), \n            // \n            '', '', '#f5a623'\n        );\n\n        if (Object.values(ids).find((n) => n > 1)) {\n            console.warn('Literal', 'same renderer rendered multiple times in batch', ids);\n        }\n\n        groupEnd();\n\n        if (t1 - t0 > 0.016) {\n            log('render took longer than a frame (0.016s) ' + (t1 - t0).toFixed(3) + 's', '', '', '', '#ba4029');\n        }\n    }\n}\n\n/**\ncue(renderer, args)\nCues a renderer to be rendered in the next batch with latest args. If the\nrenderer is already cued, args are replaced with latest args.\n**/\n\nexport function cue(renderer, args) {\n    renderer.cuedArguments = args;\n\n    // Ignore if renderer is already cued\n    if (renderer.cued) {\n        return promise;\n    }\n\n    // Create a new batch end promise where required\n    if (!cued) {\n        cued = promise.then(render);\n    }\n\n    renderers.push(renderer);\n    renderer.cued = true;\n    return cued;\n}\n\n/** \nuncue(renderer)\nRemoves renderer from the render queue.\n**/\n\nexport function uncue(renderer) {\n    if (!renderers.length) { return; }\n    if (!renderer.cued) { return; }\n\n    const i = renderers.indexOf(renderer);\n    if (i > 0) { renderers.splice(i, 1); }\n    renderer.cuedArguments = undefined;\n    renderer.cued = false;\n}\n", "\n/** \nTemplate tags\n\nLiteral template tags can contain any valid JavaScript expression. The renderer\ndecides how to render the evaluated output of each tag based on its type and \nconstructor. Where an expression evaluates to a promise, the promise resolves \nbefore being rendered.\n\n<table class=\"striped-table x-bleed\">\n    <thead>\n        <tr>\n            <th style=\"width:20%;\">Type</th>\n            <th>Expression</th>\n            <th style=\"width:30%;\">Rendered as</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>undefined</th>\n            <th><code>${ undefined }</code></th>\n            <td>\n                <template id=\"value-undefined\">${ undefined }</template>\n                <literal-include src=\"#value-undefined\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>null</th>\n            <th><code>${ null }</code></th>\n            <td>\n                <template id=\"value-null\">${ null }</template>\n                <literal-include src=\"#value-null\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>NaN</th>\n            <th><code>${ NaN }</code></th>\n            <td>\n                <template id=\"value-nan\">${ NaN }</template>\n                <literal-include src=\"#value-nan\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>String</th>\n            <th><code>${ 'Hello' }</code></th>\n            <td>\n                <template id=\"value-string\">${ 'Hello' }</template>\n                <literal-include src=\"#value-string\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Number</th>\n            <th><code>${ 100.3 }</code></th>\n            <td>\n                <template id=\"value-number\">${ 100.3 }</template>\n                <literal-include src=\"#value-number\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Infinity</th>\n            <th><code>${ Infinity }, ${ -Infinity }</code></th>\n            <td>\n                <template id=\"value-infinity\">${ Infinity }, ${ -Infinity }</template>\n                <literal-include src=\"#value-infinity\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Function</th>\n            <th><code>${ function name(param) {} }</code></th>\n            <td>\n                <template id=\"value-function\">${ function name(param) {} }</template>\n                <literal-include src=\"#value-function\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Arrow</th>\n            <th><code>${ (param) => {} }</code></th>\n            <td>\n                <template id=\"value-arrow\">${ (param) => {} }</template>\n                <literal-include src=\"#value-arrow\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>RegExp</th>\n            <th><code>${ /^regexp/ }</code></th>\n            <td>\n                <template id=\"value-regexp\">${ /^regexp/ }</template>\n                <literal-include src=\"#value-regexp\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Symbol</th>\n            <th><code>${ Symbol('name') }</code></th>\n            <td>\n                <template id=\"value-symbol\">${ Symbol('name') }</template>\n                <literal-include src=\"#value-symbol\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Array</th>\n            <th><code>${ [0, 1, 2, 3] }</code></th>\n            <td>\n                <template id=\"value-array\">${ [0, 1, 2, 3] }</template>\n                <literal-include src=\"#value-array\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Object</th>\n            <th><code>${ { property: 'value' } }</code></th>\n            <td>\n                <template id=\"value-object\">${ { property: 'value' } }</template>\n                <literal-include src=\"#value-object\"></literal-include>\n            </td>\n        </tr>\n        <tr>\n            <th>Node</th>\n            <th><code>${ document.createTextNode('Text') }</code></th>\n            <td>\n                <template id=\"value-node\">${ document.createTextNode('Text') }</template>\n                <literal-include src=\"#value-node\"></literal-include>\n            </td>\n        </tr>\n    </tbody>\n</table>\n**/\n\nimport id       from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport toType   from '../../fn/modules/to-type.js';\n\n// Matches the arguments list in the result of fn.toString()\nconst rarrowents = /\\s*(\\([\\w,\\s]*\\))/;\nconst rarguments = /function(?:\\s+\\w+)?\\s*(\\([\\w,\\s]*\\))/;\n\nexport default overload(toType, {\n    /** \n    \n    **/\n    'boolean': (value) => value + '',\n\n    // Print function and parameters\n    'function': (value) => (\n        value.prototype ?\n            (value.name || 'function') + (rarguments.exec(value.toString()) || [])[1] :\n            (rarrowents.exec(value.toString()) || [])[1] + ' ⇒ {…}'\n    ),\n\n    // Convert NaN to empty string and Infinity to ∞ symbol\n    'number': (value) => (\n        Number.isNaN(value) ? '' :\n        Number.isFinite(value) ? value + '' :\n        value < 0 ? '-∞' : '∞'\n    ),\n\n    'string': id,\n\n    'symbol': (value) => value.toString(),\n\n    'undefined': (value) => '',\n\n    'object': overload((object) => (object && object.constructor.name), {\n        'RegExp':  (object) => '/' + object.source + '/',\n        'null':    () => '',\n        'default': (object) => JSON.stringify(object, null, 2)\n    }),\n\n    'default': JSON.stringify\n});\n", "\nimport nothing        from '../../../fn/modules/nothing.js';\nimport noop           from '../../../fn/modules/noop.js';\nimport reads          from '../../../fn/observer/reads.js';\nimport { getTarget }  from '../../../fn/observer/observer.js';\nimport { cue, uncue } from './batcher.js';\nimport toText         from '../to-text.js';\nimport { meta }       from './analytics.js';\n\nconst assign = Object.assign;\n\nconst isPromise = (object) => (object && typeof object === 'object' && object.then);\n\nconst reduce = (values) => values.reduce((output, value) => (\n    // Ignore undefined and empty strings\n    value === '' || value === undefined ?\n        output :\n        output + value\n));\n\nexport function renderStopped() {\n    console.trace('Attempted .render() of stopped renderer', this.id, '#' + this.template, this.path, this.name);\n}\n\nfunction stringify(value, string, render) {\n    return value && typeof value === 'object' ? (\n        // If expression returns a promise\n        value.then ?\n            value.then((value) => (\n                string === '' ?\n                    value :\n                    string + value\n            )) :\n        // If expression returns an array with promises\n        value.find ?\n            value.find(isPromise) ?\n                // Resolve promises and join to string\n                Promise\n                .all(value)\n                .then((strings) => (\n                    string === '' ?\n                        reduce(strings.map(render)) :\n                        string + reduce(strings.map(render))\n                )) :\n            // Otherwise join to string immediately\n            string === '' ? \n                reduce(value.map(render)) :\n                string + reduce(value.map(render)) :\n        // pass any other value to render\n        string === '' ?\n            render(value) :\n            string + render(value)\n    ) :\n    string === '' ?\n        render(value) :\n        string + render(value) ;\n}\n\nexport function renderString(values) {\n    const strings = values[0];\n    return reduce(strings.map((string, i) => (\n        //console.log(typeof string, string),\n        i <= values.length ?\n            // Strings 0 to n - 1\n            stringify(values[i + 1], string, toText) :\n            // Final string\n            string === '' ? undefined :\n            string\n    )));\n}\n\nexport function removeNodes(first, last) {\n    // Remove last to first and all nodes in between\n    let node  = last;\n    let count = 0;\n\n    while (node && node !== first) {\n        const previous = node.previousSibling;\n        node.remove();\n        node = previous;\n        ++count;\n    }\n\n    // Treat the marker node specially as it may have been extended with marker.remove()...\n    // see include(). TODO: this could do with a bit of a rethink, maybe go back to\n    // allowing return of contents rather than just nodes.\n    first.constructor.prototype.remove.apply(first);\n    ++count;\n\n    return count;\n}\n\n\n/** \nRenderer()\nBase class/mixin for providing contents with the properties \n`{ node, path }` and a generic `.render()` method.\n**/\n\nfunction stop(stopable) {\n    return stopable.stop ?\n        stopable.stop() :\n        stopable() ;\n}\n\n\n/* State propogation */\n\nconst postfix = '-fns';\n\nfunction createDistributor(status) {\n    const list = status + postfix;\n\n    return function listen(fn) {\n        // If we are already in state `name` call `fn` immediately. This assumes \n        // we cannot reenter a state and therefore all handlers are called once \n        // only.\n        if (this.status === name) {\n            fn();\n            // Distributor is designed to be used in templates, return undefined\n            // to avoid rendering anything.\n            return;\n        }\n\n        const fns = this[list] || (this[list] = []);\n        fns.push(fn);\n    };\n}\n\nfunction call(fn) {\n    fn();\n}\n\nfunction triggerReducer(args, renderer) {\n    const [parent, method, status, payload] = args;\n    renderer[method] && renderer[method](payload);\n    return args;\n}\n\nfunction trigger(object, method, status, payload) {\n    if (object.status === status) { return; }\n\n    const contents = object.contents;\n    if (contents) { contents.reduce(triggerReducer, arguments); }\n\n    const listeners = object[status + postfix];\n    if (listeners) { listeners.forEach(call); }\n\n    return object;\n}\n\nfunction toPaths(paths, path) {\n    // Keep paths unique\n    if (paths.includes(path)) { return; }\n\n    var prev;\n\n    // Make some attempt to remove intermediate paths traversed\n    // while getting the value at the end of the path. Warning: not 100% \n    // robust. If we want to be robust about this we need to collect gets\n    // async inside the observer, I think.\n    while(\n        (prev = paths[paths.length - 1])\n        && prev.length < path.length\n        && path.startsWith(prev)\n    ) {\n        --paths.length;\n    }\n\n    // store the path\n    paths.push(path);\n}\n\nexport default function Renderer(node, options, element) {\n    this.element  = element || node;\n    this.node     = node;\n    this.path     = options.path;\n    this.id       = ++meta.count;\n    this.count    = 0;\n    this.template = options.template;\n}\n\nassign(Renderer.prototype, {\n    render: function(data) {\n        if (window.DEBUG && this.render === renderStopped) {\n            console.error('Attempt to .render() stopped renderer', this.id, '#' + (this.template.id || this.template), (this.path ? this.path + ' ' : '') + this.constructor.name);\n        }\n\n        // Cue .render() to be called on the next batch\n        return cue(this, arguments);\n    },\n\n    update: function render(data) {\n        //console.log(this.constructor.name + '#' + this.id + '.update()');\n\n        const stops = this['stop' + postfix];\n        if (stops) {\n            stops.forEach(stop);\n            stops.length = 0;\n        }\n    \n        const paths = this.paths || (this.paths = []);\n        paths.length = 0;\n    \n        const gets = data ?\n            reads(data).each((path) => toPaths(paths, path)) :\n            nothing ;\n\n        // Update render count before rendering in case .count is used inside \n        // the template\n        ++this.count;\n\n        // Evaluate the template\n        const meta = this.literally(data, getTarget(data), this.element);\n\n        // We may only collect synchronous gets – other templates may use \n        // this data object while we are promising and we don't want to\n        // include their gets by stopping on .then(). Stop now. If we want to\n        // change this, making a data proxy per template instance would be the \n        // way to go.\n        gets.stop();\n\n        // Return count of DOM mutations\n        return meta;\n    },\n\n\n    /* States */\n\n    connected: createDistributor('dom'),\n\n    connect: function() {\n        // object, method, status, payload\n        trigger(this, 'connect', 'dom');\n    },\n\n    done: createDistributor('done'),\n\n    stop: function() {\n        uncue(this);\n        this.render = window.DEBUG ? renderStopped : noop ;\n        // object, method, status, payload\n        trigger(this, 'stop', 'done');\n        return this;\n    }\n});\n\n\n", "\nimport library   from '../library.js';\nimport compile   from '../compile.js';\nimport Renderer, { renderString } from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n\n/** \nAttributeRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nfunction setAttribute(node, name, value) {\n    if (value === node.getAttribute(name)) { return 0; }\n    // Mutate DOM\n    node.setAttribute(name, value);\n    // Return number of mutations\n    return 1;\n}\n\nexport default function AttributeRenderer(node, options) {\n    Renderer.apply(this, arguments);\n    \n    this.name      = options.name;\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, this.element);\n    \n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].attribute || (analytics[id].attribute = 1);\n    ++analytics.Totals.attribute;\n}\n\nassign(AttributeRenderer.prototype, Renderer.prototype, {\n    resolve: function() {\n        const value = renderString(arguments);\n        return setAttribute(this.node, this.name, value);\n    }\n});\n", "\nimport library   from '../library.js';\nimport Renderer, { renderString } from './renderer.js';\nimport compile   from '../compile.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n/** \nBooleanRenderer()\nConstructs an object responsible for rendering to a boolean attribute.\n**/\n\nexport function setBooleanProperty(node, name, value) {\n    if (name in node) {\n        if ((!!value) === node[name]) {\n            return 0;\n        }\n\n        node[name] = value;\n    }\n    else if (value) {\n        node.setAttribute(name, name);\n    }\n    else {\n        node.removeAttribute(name);\n    }\n\n    // Return DOM mutation count\n    return 1;\n}\n\nexport default function BooleanRenderer(node, options) {\n    Renderer.apply(this, arguments);\n    \n    this.name      = options.name;\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, this.element);\n\n    // Remove the boolean until it is processed\n    node.removeAttribute(this.name);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].boolean || (analytics[id].boolean = 1);\n    ++analytics.Totals.boolean;\n}\n\nassign(BooleanRenderer.prototype, Renderer.prototype, {\n    resolve: function() {\n        const value = renderString(arguments);\n        return setBooleanProperty(this.node, this.name, value)\n    }\n});\n", "/**\nisDefined(value)\nCheck for value – where `value` is `undefined`, `NaN` or `null`, returns\n`false`, otherwise `true`.\n*/\n\n\nexport default function isDefined(value) {\n    // !!value is a fast out for non-zero numbers, non-empty strings\n    // and other objects, the rest checks for 0, '', etc.\n    return !!value || (value !== undefined && value !== null && !Number.isNaN(value));\n}\n", "\nconst assign      = Object.assign;\nconst CustomEvent = window.CustomEvent;\n\nconst defaults    = {\n\t// The event bubbles (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tbubbles: true,\n\n\t// The event may be cancelled (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tcancelable: true\n\n\t// Trigger listeners outside of a shadow root (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n\t//composed: false\n};\n\n/**\nEvent(type, properties)\n\nCreates a CustomEvent of type `type`.\nAdditionally, `properties` are assigned to the event object.\n*/\n\nexport default function Event(type, options) {\n\tlet settings;\n\n\tif (typeof type === 'object') {\n\t\tsettings = assign({}, defaults, type);\n\t\ttype = settings.type;\n        delete settings.type;\n\t}\n\n\tif (options && options.detail) {\n\t\tif (settings) {\n\t\t\tsettings.detail = options.detail;\n\t\t}\n\t\telse {\n\t\t\tsettings = assign({ detail: options.detail }, defaults);\n\t\t}\n\t}\n\n    // Settings accepted by CustomEvent:\n    // detail:     any\n    // bubbles:    true | false\n    // cancelable: true | false\n    // composed:   true | false\n    // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n\tvar event = new CustomEvent(type, settings || defaults);\n\n\tif (options) {\n\t\tdelete options.detail;\n\t\tassign(event, options);\n\t}\n\n\treturn event;\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was \nprevented, otherwise `true`.\n\n```\ntrigger('dom-activate', node);\n```\n*/\n\n/**\ntrigger(data, node)\n\nTriggers an event described by `data` on `node`. The `data` object must have a \n`type` property. Use the `details` property to carry a data payload.\n\n```\ntrigger({\n    type: 'dom-activate',\n    details: {...}\n}, node);\n```\n\nReturns `false` if the event default was prevented, otherwise `true`.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport Event from './event.js';\n\nexport function trigger(type, node) {\n    let properties;\n\n    if (typeof type === 'object') {\n        properties = type;\n        type = properties.type;\n        delete properties.type;\n    }\n\n    // Don't cache events. It prevents you from triggering an event of a\n\t// given type from inside the handler of another event of that type.\n\tconst event = Event(type, properties);\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n", "\nexport default {\n    changeEvent: 'dom-update'\n}\n", "\nimport isDefined from '../../../fn/modules/is-defined.js';\nimport trigger   from '../../../dom/modules/trigger.js';\nimport config    from '../config.js';\nimport library   from '../library.js';\nimport compile   from '../compile.js';\nimport Renderer  from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign  = Object.assign;\nconst rempty  = /^\\s*$/;\n\nfunction isNotEmpty(string) {\n    return !rempty.test(string);\n}\n\n\n/** \nCheckedRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nfunction toString(value) {\n    return '' + value;\n}\n\nfunction setChecked(node, value, hasValue) {\n        // Value may be a boolean in which case we use it directly\n    const checked = typeof value === 'boolean' ? value :\n        // If the element has a value attribute defined, we compare against it\n        hasValue ?\n            // Is value an array of values? It's important to include this here, \n            // at least for checkboxes, of which multiple may be checked. It \n            // cuts down on tag parsing in lists of inputs.\n            node.type === 'checkbox' && value && value.map ?\n                value.map(toString).includes(node.value) :\n                // Or a string or a number?\n                value + '' === node.value :\n        // Otherwise treat value as a boolean\n        !!value ;\n\n    if (checked === node.checked) {\n        return 0;\n    }\n\n    node.checked = checked;\n\n    // Optional event hook\n    if (config.changeEvent) { \n        trigger(config.changeEvent, node);\n    }\n\n    // Return DOM mod count\n    return 1;\n}\n\nexport default function CheckedRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'checked';\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, this.element);\n    this.hasValue  = isDefined(node.getAttribute('value'));\n\n    // Negate the effects of having template content in the checked attribute -\n    // resetting the form sets it back to attribute state\n    node.removeAttribute('checked');\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].checked || (analytics[id].checked = 1);\n    ++analytics.Totals.checked;\n}\n\nassign(CheckedRenderer.prototype, Renderer.prototype, {\n    resolve: function renderBoolean(strings, value) {\n        if (arguments.length !== 2 || strings.find(isNotEmpty)) {\n            throw new Error('A checked attribute may contain only one ${ tag }, optionally surrounded by white space');\n        }\n\n        return setChecked(this.node, value, this.hasValue)\n    }\n});\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'` \nis aliased to `'textContent'`. The property `'tag'` is treated as an alias \nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The \nproperty `'is'` is also ignored.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport id from '../../fn/modules/id.js';\nimport noop from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tcontent.forEach((child) => { node.appendChild(child) });\n\t},\n\n\t// SVG points property must be set as string attribute - SVG elements\n\t// have a read-only API exposed at .points\n\tpoints: setAttribute,\n    cx:     setAttribute,\n    cy:     setAttribute,\n    r:      setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox: setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport toType from '../../fn/modules/to-type.js';\nimport assign from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\nconst div = document.createElement('div');\n\n\n// Constructors\n\nfunction constructHTML(tag, html) {\n    var node = document.createElement(tag);\n\n    if (html) {\n        node.innerHTML = html;\n    }\n\n    return node;\n}\n\nfunction constructSVG(tag, html) {\n    var node = document.createElementNS(svgNamespace, tag);\n\n    if (html) {\n        node.innerHTML = html;\n    }\n\n    return node;\n}\n\nconst construct = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: function(tag, html) {\n        var fragment = document.createDocumentFragment();\n\n        if (html) {\n            div.innerHTML = html;\n            const nodes = div.childNodes;\n            while (nodes[0]) {\n                fragment.appendChild(nodes[0]);\n            }\n        }\n\n        return fragment;\n    },\n\n    text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },\n\n    circle:   constructSVG,\n    ellipse:  constructSVG,\n    g:        constructSVG,\n    glyph:    constructSVG,\n    image:    constructSVG,\n    line:     constructSVG,\n    rect:     constructSVG,\n    use:      constructSVG,\n    path:     constructSVG,\n    pattern:  constructSVG,\n    polygon:  constructSVG,\n    polyline: constructSVG,\n    svg:      constructSVG,\n    default:  constructHTML\n});\n\n\n\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n- Where `tag` is an object, it must have a `\"tag\"` or `\"tagName\"` property.\nA node is created according to the above rules for tag strings, and other\nproperties of the object are assigned with dom's `assign(node, object)` function.\n\nIf `content` is a string it is set as text content on a text or comment node,\nor as inner HTML on an element or fragment. It may also be an object of\nproperties which are assigned with dom's `assign(node, properties)` function.\n*/\n\nfunction toTypes() {\n    return Array.prototype.map.call(arguments, toType).join(' ');\n}\n\nfunction validateTag(tag) {\n    if (typeof tag !== 'string') {\n        throw new Error('create(object, content) object must have string property .tag or .tagName');\n    }\n}\n\nexport default overload(toTypes, {\n    'string': construct,\n\n    'string undefined': construct,\n\n    'string string': construct,\n\n    'string object': function(tag, content) {\n        return assign(construct(tag, ''), content);\n    },\n\n    'object string': function(properties, text) {\n        const tag = properties.tag || properties.tagName;\n        validateTag(tag);\n        // Warning: text is set before properties, but text should override\n        // html or innerHTML property, ie, be set after.\n        return assign(construct(tag, text), properties);\n    },\n\n    'object object': function(properties, content) {\n        const tag = properties.tag || properties.tagName;\n        validateTag(tag);\n        return assign(assign(construct(tag, ''), properties), content);\n    },\n\n    default: function() {\n        throw new Error('create(tag, content) does not accept argument types \"' + Array.prototype.map.call(arguments, toType).join(' ') + '\"');\n    }\n});\n", "\nimport create         from '../../../dom/modules/create.js';\nimport library        from '../library.js';\nimport compile        from '../compile.js';\nimport toText         from '../to-text.js';\nimport analytics, { meta } from './analytics.js';\nimport Renderer, { removeNodes } from './renderer.js';\nimport TemplateRenderer from './template-renderer.js';\nimport print          from '../../library/print.js';\nimport { cue }        from './batcher.js';\n\nconst assign = Object.assign;\n\nfunction replace(array, current, replacement) {\n    const i = array.indexOf(current);\n    if (i === -1) {\n        throw new Error('Renderer not in contents array')\n    }\n    array.splice(i, 1, replacement);\n    return array;\n}\n\nfunction replaceObjectContent(renderer, value) {\n    // Value is not an object\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n\n    // Array-like values are flattened recursively\n    if (!value.nodeType && typeof value.length === 'number') {\n        console.log('TODO: promised or streamed value is an array - deal wid\\' it');\n        return true;\n    }\n\n    // Nodes are pushed into contents directly\n    if (value instanceof Node) {\n        renderer.content.replaceWith(value);\n        renderer.content = value;\n        return true;\n    }\n\n    // Value is a TemplateRenderer\n    if (value instanceof TemplateRenderer) {\n        renderer.content.replaceWith(value.content);\n        renderer.content = value;\n        renderer.status === 'dom' && value.connect();\n        return true;\n    }\n\n    // Value is a Stream\n    if (value.each) {\n        const child = new StreamRenderer(value);\n        renderer.content.replaceWith(child.content);\n        renderer.content = child;\n        renderer.status === 'dom' && child.connect();\n        return true;\n    }\n    \n    // Value is a Promise\n    if (value.then) {\n        const child = new PromiseRenderer(value);\n        renderer.content.replaceWith(child.content);\n        renderer.content = child;\n        renderer.status === 'dom' && child.connect();\n        return true;\n    }\n}\n\n/* PromiseRenderer */\n\nfunction PromiseRenderer(contents, promise) {\n    // Parent collection\n    this.collection = contents;\n    // Marker content\n    this.content = create('text', '');\n    this.id      = ++meta.count;\n\n    promise\n    .then(value => this.status !== 'done' && this.push(value))\n    .catch(e => this.print(e));\n}\n\nassign(PromiseRenderer.prototype, {\n    push: function(value) {\n        this.status !== 'done' && cue(this, arguments);\n        return this;\n    },\n\n    update: function(value) {\n        // Replace this promise renderer in the contents collection, \n        // effectively retiring it from active service\n        if (!replaceObjectContent(this, value)) {\n            this.content.textContent = toText(value);\n        }\n\n        //replace(this.collection, this, this.content);\n        this.status = 'done';\n        return 1;\n    },\n\n    print: window.DEBUG ?\n        function(e) { this.content.replaceWith(print(e)) } :\n        function() { this.content.remove(); },\n\n    remove: function() {\n        this.content.remove();\n    },\n\n    replaceWith: function(node) {\n        this.content.replaceWith(node);\n    },\n\n    stop: function() {\n        if (this.status === 'done') { return; }\n        this.status = 'done';\n        this.content.stop && this.content.stop();\n    },\n\n    connect: function() {\n        if (this.status === 'dom') { return; }\n        this.status = 'dom';\n        this.content.connect && this.content.connect();\n    }\n});\n\n\n/* SteeamRenderer */\n\nfunction StreamRenderer(stream) {\n    // Marker node\n    const marker = create('text', '');\n    this.marker  = marker;\n    this.content = marker;\n    this.id      = ++meta.count;\n    this.stream  = stream;\n\n    stream.pipe(this);\n}\n\nassign(StreamRenderer.prototype, PromiseRenderer.prototype, {\n    update: function(value) {\n        stop(this.content);\n\n        if (replaceObjectContent(this, value)) {\n            return 1;\n        }\n\n        // Value is converted to a string\n        this.marker.textContent = toText(value);\n        if (this.content !== this.marker) {\n            this.content.replaceWith(this.marker);\n            this.content = this.marker;\n        }\n\n        return 1;\n    },\n\n    stop: function() {\n        if (this.status === 'done') { return; }\n        this.status = 'done';\n        this.stream.stop && this.stream.stop();\n        this.content.stop && this.content.stop();\n    }\n});\n\n\n/* ContentRenderer */\n\nfunction renderValues(contents, string, array) {\n    const l = array.length;\n    let n = -1;\n    while (++n < l) {\n        string = renderValue(contents, string, array[n]);\n    }\n    return string;\n}\n\nfunction renderValue(renderer, string, value) {\n    const contents = renderer.contents;\n\n    if (value && typeof value === 'object') {\n        // Array-like values are flattened recursively\n        if (!value.nodeType && typeof value.length === 'number') {\n            return renderValues(renderer, string, value);\n        }\n\n        // Nodes are pushed into contents directly\n        if (value instanceof Node) {\n            string && contents.push(string);\n            contents.push(value);\n            return '';\n        }\n\n        // Value is a TemplateRenderer\n        if (value instanceof TemplateRenderer) {\n            string && contents.push(string);\n            contents.push(value);\n            return '';\n        }\n\n        // Value is a Stream\n        if (value.each) {\n            string && contents.push(string);\n            contents.push(new StreamRenderer(value));\n            return '';\n        }\n\n        // Value is a Promise\n        if (value instanceof Promise) {\n            string && contents.push(string);\n            contents.push(new PromiseRenderer(contents, value))\n            return '';\n        }\n    }\n\n    // If none of the above conditions were met value must coerce to a string\n    return string + toText(value);\n}\n\n\n/**\nContentRenderer()\nConstructs an object responsible for rendering to a text node. If the result of\nprocessing the literal content is more DOM content this renderer will insert \nthat DOM after the text node.\n**/\n\nfunction setNodeValue(node, value) {\n    if (node.nodeValue !== value) {\n        node.nodeValue = value;\n        return 1;\n    }\n\n    return 0;\n}\n\nfunction stop(node) {\n    node && typeof node === 'object' && node.stop && node.stop();\n}\n\nfunction toContent(object) {\n    return typeof object === 'string' ? object :\n        object.content ? toContent(object.content) :\n        object ;\n}\n\nfunction setContents(first, last, contents, state) {\n    let count = 0;\n    \n    // TODO: get rid of need to slice\n    contents = contents.slice().map(toContent);\n\n    // Remove existing nodes, leaving first and last alone\n    if (last.previousSibling !== first) {\n        count += removeNodes(first.nextSibling, last.previousSibling);\n    }\n\n    // Set first text node\n    if (typeof contents[0] === 'string') {\n        count += setNodeValue(first, contents.shift());\n    }\n    else {\n        count += setNodeValue(first, '');\n    }\n\n    // Set last text node\n    if (typeof contents[contents.length - 1] === 'string') {\n        count += setNodeValue(last, contents.pop());\n    }\n    else {\n        count += setNodeValue(last, '');\n    }\n\n    if (contents.length) {\n        first.after.apply(first, contents);\n        state === 'dom' && contents.forEach((renderer) => {\n            console.log('DOES THIS EVER HAPPEN? renderer.connect()', renderer);\n            renderer.connect && renderer.connect();\n        });\n        count += contents.length;\n    }\n\n    return count;\n}\n\nexport default function ContentRenderer(node, options, element) {\n    Renderer.apply(this, arguments);\n\n    this.first     = node;\n    this.last      = document.createTextNode('');\n    this.first.after(this.last);\n    this.contents  = [];\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, element);\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].text || (analytics[id].text = 1);\n    ++analytics.Totals.text;\n}\n\nassign(ContentRenderer.prototype, Renderer.prototype, {\n    render: function() {\n        // Preemptively stop all nodes, they are about to be updated\n        this.contents.forEach(stop);\n        this.contents.length = 0;\n        return Renderer.prototype.render.apply(this, arguments);\n    },\n\n    update: function() {\n        // Stop all nodes, they are about to be recreated. This needs to be done\n        // here as well as render, as update may be called by TemplateRenderer\n        // without going through .render() cueing first.\n        this.contents.forEach(stop);\n        this.contents.length = 0;\n        return Renderer.prototype.update.apply(this, arguments);\n    },\n\n    resolve: function(strings) {\n        // Surely not here, tho?\n        //this.contents.forEach(stop);\n        //this.contents.length = 0;\n\n        let n = -1;\n        let string = '';\n    \n        while (strings[++n] !== undefined) {\n            // Append to string until it has to be pushed to contents because\n            // a node or renderer has to be pushed in behind it\n            string = renderValue(this, string + strings[n], arguments[n + 1]);\n        }\n\n        string && this.contents.push(string);\n        return setContents(this.first, this.last, this.contents, this.status);\n    }\n});\n", "\nimport overload  from '../../../fn/modules/overload.js';\nimport library   from '../library.js';\nimport compile   from '../compile.js';\nimport toText    from '../to-text.js';\nimport Renderer  from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n\nconst nothing = [];\n\n/** \nTokensRenderer()\nConstructs an object responsible for rendering to a token list attribute such\nas a class attribute.\n**/\n\nconst getTokenList = overload((node, name) => name, {\n    'class': (node) => node.classList\n});\n\nfunction valueify(value) {\n    return (value && typeof value === 'object' && value.length !== undefined) ?\n        value.join(' ') :\n        toText(value) ;\n}\n\nfunction renderValues(args) {\n    const [strings] = args;\n    var string = '';\n    var n = -1 ;\n    var value;\n\n    while (strings[++n] !== undefined) {\n        // Don't strip spaces, but do ignore empty strings\n        if (strings[n]) {\n            string += ' ' + strings[n];\n        }\n\n        // If a value is more than nothing push it in\n        value = args[n + 1];\n        if (value !== undefined && value !== '') {\n            string += ' ' + valueify(value);\n        }\n    }\n\n    return string;\n}\n\nfunction setTokens(tokens, cached, values, count) {\n    // Remove tokens from the cache that are found in new tokens.\n    let n = cached.length;\n\n    while (n--) {\n        if (tokens.indexOf(cached[n]) !== -1) {\n            cached.splice(n, 1);\n        }\n    }\n\n    // Remove the remainder from the tokens\n    if (cached.length) {\n        tokens.remove.apply(tokens, cached);\n        ++count;\n    }\n\n    // Then add the new tokens. The TokenList object ignores tokens it \n    // already contains so doubles are not set.\n    tokens.add.apply(tokens, values);\n    return ++count;\n}\n\nexport default function TokensRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = options.name;\n    this.tokens    = getTokenList(node, options.name);\n    this.cached    = nothing;\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, node);\n\n    // Empty the tokens until it is rendered to avoid words in literal tags\n    // being interpreted as classes\n    node.setAttribute(this.name, '');\n\n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].class || (analytics[id].class = 1);\n    ++analytics.Totals.class;\n}\n\nassign(TokensRenderer.prototype, Renderer.prototype, {\n    resolve: function() {\n        const string  = renderValues(arguments);\n        const classes = string.trim().split(/\\s+/);\n        const count   = setTokens(this.tokens, this.cached, classes, 0);\n        this.cached = classes;\n        return count;\n    }\n});\n", "\nimport trigger   from '../../../dom/modules/trigger.js';\nimport config    from '../config.js';\nimport library   from '../library.js';\nimport compile   from '../compile.js';\nimport Renderer, { renderString } from './renderer.js';\nimport analytics from './analytics.js';\n\nconst assign = Object.assign;\n\n\n/** \nValueRenderer()\nConstructs an object responsible for rendering to a plain text attribute.\n**/\n\nconst rempty = /^\\s*$/;\n\nconst types = {\n    'number': 'number',\n    'range':  'number'\n};\n\nfunction addValue(result, value) {\n    return result === undefined ? \n        value :\n        result + value ;\n}\n\nfunction renderValue(values) {\n    const strings = values[0];\n    let value = rempty.test(strings[0]) ? undefined : strings[0];\n    let n = 0;\n\n    while (strings[++n] !== undefined) {\n        value = addValue(value, values[n]);\n\n        if (!rempty.test(strings[n])) {\n            value = addValue(value, strings[n]);\n        }\n    }\n\n    return value;\n}\n\n\n/**\nsetProperty(node, name, value)/\n**/\n\nexport function setProperty(node, name, value) {\n    // Bit of an edge case, but where we have a custom element that has not\n    // been upgraded yet, but it gets a property defined on its prototype when\n    // it does upgrade, setting the property on the instance now will mask the\n    // ultimate get/set definition on the prototype when it does arrive.\n    //\n    // So don't, if property is not in node. Set the attribute, it will be\n    // picked up on upgrade.\nif (value === null) {\n    throw new Error('VALUE');\n}\n//console.log('VALUE', value);\n    \n    if (name in node) {\n        node[name] = value;\n    }\n    else {\n        node.setAttribute(name, value);\n    }\n\n    // Return DOM mutation count\n    return 1;\n}\n\nfunction setValue(node, value) {\n    // Don't render into focused nodes, it makes the cursor jump to the\n    // end of the field, and we should cede control to the user anyway\n    if (document.activeElement === node) {\n        return 0;\n    }\n\n    const type = types[node.type];\n    value = type === undefined ? value :\n        typeof value === type ? value :\n        null ;\n\n    // Avoid updating with the same value. Support node values of any type to \n    // support custom elements (like <range-control>), as well as values that \n    // are always strings\n    if (value === node.value || (value + '') === node.value) {\n        return 0;\n    }\n\n    // Here's how we did it for number\n    //if (value === (node.value === '' ? null : +node.value)) { return 0; }\n\n    const count = setProperty(node, 'value', value);\n\n    // Optional event hook\n    if (config.changeEvent) { \n        trigger(config.changeEvent, node);\n    }\n\n    // Return DOM mod count\n    return count;\n}\n\nexport default function ValueRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'value';\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, node);\n    \n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].value || (analytics[id].value = 1);\n    ++analytics.Totals.value;\n}\n\nassign(ValueRenderer.prototype, Renderer.prototype, {\n    resolve: function() {\n        const value = renderValue(arguments);\n        return setValue(this.node, value)\n    }\n});\n\n\n/** \nStringValueRenderer()\nConstructs an object responsible for rendering to a value property as a string.\n**/\n\nexport function StringValueRenderer(node, options) {\n    Renderer.apply(this, arguments);\n\n    this.name      = 'value';\n    this.literally = options.literally || compile(library, 'data, state, element', options.source, null, options, node);\n    \n    // Analytics\n    const id = '#' + options.template;\n    ++analytics[id].value || (analytics[id].value = 1);\n}\n\nassign(StringValueRenderer.prototype, Renderer.prototype, {\n    resolve: function() {\n        const value = renderString(arguments);\n        return setValue(this.node, value)\n    }\n});\n", "\nconst textarea = document.createElement('textarea');\n\nexport default function decode(html) {\n    // Converts &amp;, &lt; and &gt; to &, < and >\n    textarea.innerHTML = html;\n    return textarea.value;\n}\n", "\nimport noop     from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\nimport toType   from '../../dom/modules/to-type.js';\n\nimport AttributeRenderer from './renderers/attribute-renderer.js';\nimport BooleanRenderer   from './renderers/boolean-renderer.js';\nimport CheckedRenderer   from './renderers/checked-renderer.js';\nimport ContentRenderer   from './renderers/content-renderer.js';\nimport TokensRenderer    from './renderers/tokens-renderer.js';\nimport ValueRenderer, { StringValueRenderer } from './renderers/value-renderer.js';\n\nimport decode   from './decode.js';\n\nconst A = Array.prototype;\nconst rliteral = /\\$\\{/;\n\n\n/** \ncompileAttributes(renderers, options, nodeames)\n**/\n\nfunction addAttributeRenderer(renderers, Renderer, node, source, name, options) {\n    if (!source || !rliteral.test(source)) { return; }\n    options.source = source;\n    options.name   = name;\n    renderers.push(new Renderer(node, options));\n}\n\nfunction compileAttr(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, AttributeRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileBoolean(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, BooleanRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileTokens(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, TokensRenderer, node, attribute.value, attribute.localName, options);\n}\n\nfunction compileValue(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, ValueRenderer, node, attribute.value, 'value', options);\n}\n\nfunction compileValueString(renderers, options, node, attribute) {\n    addAttributeRenderer(renderers, StringValueRenderer, node, attribute.value, 'value', options);\n}\n\n\nconst compileAttribute = overload((renderers, options, node, attribute) => attribute.localName, {\n    'checked':  function compileChecked(renderers, options, node, attribute) {\n        addAttributeRenderer(renderers, CheckedRenderer, node, attribute.value, 'checked', options);\n    },\n\n    'class': compileTokens,\n\n    'datetime': function compileDatetime(renderers, options, node, attribute) {\n        if (window.DEBUG) { console.log('Todo: compile datetime attribute'); }\n    },\n\n    'disabled': compileBoolean,\n    'hidden': compileBoolean,\n\n    // Special workaround attribute used in cases where ${} cannot be added\n    // directly to the HTML content, such as in <tbody> or <tr>\n    'inner-content': function(renderers, options, node, attribute) {\n        const string = attribute.value;\n        if (!string || !rliteral.test(string)) { return; }\n        node.removeAttribute(attribute.localName);\n        options.source = decode(string);\n        options.name   = 'innerHTML';\n        renderers.push(new ContentRenderer(node, options));\n    },\n\n    'required': compileBoolean,\n\n    'value': overload((renderers, options, node, attribute) => ('' + node.type), {\n        //'checkbox':  compileValueChecked,\n        //'date':      compileValueDate,\n        //'number':    compileValueNumber,\n        //'range':     compileValueNumber,\n        //'select-multiple': compileValueArray,\n        'text':       compileValueString,\n        'search':     compileValueString,\n        'select-one': compileValueString,\n        'default':    compileValue,\n        'undefined':  compileAttr\n    }),\n\n    'default': compileAttr\n});\n\nfunction compileAttributes(renderers, options, node) {\n    // Attributes may be removed during parsing so copy the list before looping\n    const attributes = A.slice.apply(node.attributes);\n    var n = -1, attribute;\n    // Todo: order attributes so that min, max, value come last?\n    while (attribute = attributes[++n]) {\n        compileAttribute(renderers, options, node, attribute);\n    }\n}\n\n\n/**\ncompileElement()\n**/\n\nfunction compileChildren(renderers, options, node) {\n    const children = node.childNodes;\n\n    if (children) {\n        const path = options.path;\n        let n = -1;\n\n        while(children[++n]) {\n            options.path = path ? path + '.' + n : '' + n;\n            compileNode(renderers, options, children[n], node);\n        }\n\n        // Put path back to what it was or subsequent renderers will get an\n        // erroneous path\n        options.path = path;\n    }\n\n    return renderers;\n}\n\nconst compileElement = overload((renderers, options, node) => node.tagName.toLowerCase(), {\n    // Ignore SVG <defs>, which for our purposes we consider as inert like \n    // HTML's <template>\n    'defs': noop,\n\n    'default': (renderers, options, node) => {\n        // Children first\n        compileChildren(renderers, options, node);\n\n        // We must wait until custom elements are upgraded before we may \n        // interact with their non-standard properties and attributes\n        // Todo:\n        // Hang on... is this still true given that the renderer.set negociates\n        // the way an attribute is rendered??\n        /*const tag = node.getAttribute('is') || node.tagName.toLowerCase();\n        if (/-/.test(tag)) {\n            window.customElements.whenDefined(node.tagName).then(() => {\n                compileAttributes(renderers, options, node);\n                compileType(renderers, options, node);\n            });\n        }\n        else {*/\n            compileAttributes(renderers, options, node);\n            //compileType(renderers, options, node);\n        /*}*/\n        \n        return renderers;\n    }\n});\n\n\n/** \ncompileNode()\n**/\n\nconst compileNode = overload((renderers, options, node) => toType(node), {\n    'comment': noop,\n\n    'element': compileElement,\n\n    'fragment': compileChildren,\n\n    'text': (renderers, options, node, element) => {\n        const string = node.nodeValue;\n\n        if (string && rliteral.test(string)) {\n            options.source = decode(string);\n            options.name   = null;\n            renderers.push(new ContentRenderer(node, options, element));\n        }\n\n        return renderers;\n    },\n\n    'doctype': noop,\n\n    'document': (renderers, options, node) => {\n        compileChildren(renderers, options, node);\n        return renderers;\n    },\n\n    'default': () => {\n        throw new Error('Node not compileable');\n    }\n});\n\nexport default compileNode;\n", "\n/** \nTemplateRenderer(template)\n\nImport the `TemplateRenderer` constructor from the main module:\n\n```js\nimport TemplateRenderer from 'https://stephen.band/literal/module.js';\n```\n\nThe `TemplateRenderer` constructor takes a template element, or the `id` of a \ntemplate element, and creates a renderer of a clone of the template's content.\nA renderer manages an asynchronous lifecycle of content renders, updating its \nDOM nodes in response to changing data.\n\n```js\nconst renderer = new TemplateRenderer('id');\nconst data     = {};\n\n// Cue data for render then add it to the DOM\nrenderer\n.render(data)\n.then(() => document.body.append(renderer.content));\n```\n**/\n\nimport getPath     from '../../../fn/modules/get-path.js';\nimport nothing     from '../../../fn/modules/nothing.js';\nimport identify    from '../../../dom/modules/identify.js';\nimport isTextNode  from '../../../dom/modules/is-text-node.js';\nimport compileNode from '../compile-node.js';\nimport { Observer, getTarget } from '../../../fn/observer/observer.js';\nimport observe     from '../../../fn/observer/observe.js';\nimport analytics, { meta } from './analytics.js';\nimport Renderer, { removeNodes } from './renderer.js';\n\nconst assign = Object.assign;\nconst cache  = {};\n\n\n/*\nTemplateRenderer\nDescendant paths are stored in the form `\"1.12.3.class\"`, enabling fast \ncloning of template instances without retraversing their DOMs looking for \nliteral attributes and text.\n*/\n\nfunction child(parent, index) {\n    return /^[a-zA-Z]/.test(index) ?\n        parent :\n        parent.childNodes[index] ;\n}\n\nfunction getDescendant(path, root) {\n    const p = path.split(/\\./);\n    return p.reduce(child, root);\n}\n\nfunction isMarkerNode(node) {\n    // Markers should be spaces-only else we risk unrendered content being \n    // inserted into the DOM. If it's not a text node, it's not a marker \n    // node because it could contain something that contains unrendered code.\n    if (!isTextNode(node)) { \n        return false;\n    }\n\n    const text  = node.nodeValue;\n    const space = /^\\s*/.exec(text);\n\n    // If text is more than just space return false\n    return space[0].length === text.length;\n}\n\nfunction prepareContent(content) {\n    // Due to the way HTML is usually written the vast majority of templates\n    // start and end with a text node, usually containing some white space\n    // and new lines. The renderer uses these as delimiters for the start and\n    // end of templated content – where it can. If the template does NOT start \n    // or end with a text node, we insert text nodes where needed.\n    const first = content.childNodes[0];\n    const last  = content.childNodes[content.childNodes.length - 1];\n\n    if (!isMarkerNode(first)) {\n        content.prepend(document.createTextNode(''));\n    }\n\n    if (!isMarkerNode(last)) {\n        content.append(document.createTextNode(''));\n    }\n}\n\nfunction newRenderer(renderer) {\n    // `this` is the parent renderer of the new renderer\n    const node    = getDescendant(renderer.path, this.content);\n    const element = isTextNode(node) ? node.parentNode : node ;\n    return new renderer.constructor(node, renderer, element);\n}\n\nexport default function TemplateRenderer(template) {\n    // TemplateRenderer may be called with a string id or a template element\n    const id = typeof template === 'string' ?\n        template :\n        identify(template) ;\n\n    this.id          = ++meta.count;\n    this.observables = nothing;\n\n    // If the template is already compiled, clone the compiled contents to \n    // this renderer and bind them to a new fragment\n    if (cache[id]) {\n        const template = cache[id].template;\n        this.template  = template;\n        this.content   = template.content.cloneNode(true);\n        this.first     = this.content.childNodes[0];\n        this.last      = this.content.childNodes[this.content.childNodes.length - 1];\n        this.contents = cache[id].contents.map(newRenderer, this);\n        ++analytics['#' + id].template;\n        ++analytics.Totals.template;\n        return;\n    }\n\n    template = typeof template === 'string' ?\n        document.getElementById(template) :\n        template ;\n\n    if (window.DEBUG) {\n        if (!template) {\n            throw new Error('Template id=\"' + id + '\" not found in document');\n        }\n        \n        if (!template.content) {\n            throw new Error('Element id=\"' + id + '\" is not a <template> (no content fragment)');\n        }\n    }\n\n    /** \n    .content\n\n    A fragment that initially contains the renderer's DOM nodes. On creation of\n    a renderer they are in an unrendered state. They are guaranteed to be in a \n    rendered state on resolution of the first `.render()` promise. \n    \n    The fragment may be inserted into the DOM at any time, at which point it \n    will no longer contain the renderer's DOM nodes, however the renderer \n    continues to manage these nodes wherever they end up.\n    **/\n    prepareContent(template.content);\n\n    this.template  = template;\n    this.content   = template.content.cloneNode(true);\n    this.first     = this.content.childNodes[0];\n    this.last      = this.content.childNodes[this.content.childNodes.length - 1];\n\n    // Analytics (must be declared before contents)\n    analytics['#' + id] = { template: 1 };\n    ++analytics.Totals.template;\n\n    // compileNode(contents, options, content, template)\n    // The options object contains information for renderer objects. It is \n    // mutated as it is passed to each renderer (specifically path, name, \n    // source properties). We can do this because renderer construction is \n    // synchronous within a template.\n    this.contents = compileNode([], { template: id, path: '' }, this.content, template.content);\n\n    cache[id] = this;\n}\n\nfunction stop(object) {\n    object.stop();\n}\n\nassign(TemplateRenderer.prototype, {\n    /**\n    .render(data)\n    Cues `data` to be rendered in the next render batch. Returns a promise that\n    resolves when the batch is finished rendering.\n\n    The `data` object is observed for mutations, and the renderer updates it \n    content until either a new data object is cued or the renderer is stopped.\n    **/\n\n    render: function(object) {\n        this.observables.forEach(stop);\n        this.observables = nothing;\n\n        const data = object ? getTarget(object) : null ;\n\n        // Deduplicate. Not sure this is entirely necessary.\n        if (data === this.data) {\n            return Promise.reject('Attempt to render with same object as last render');\n        }\n\n        this.data = data;\n        return Renderer.prototype.render.apply(this, arguments);\n    },\n\n    update: function(object) {\n        //console.log(this.constructor.name + '#' + this.id + '.update()');\n\n        if (!object) {\n            // Remove all but the first node to the renderer's content fragment\n            const nodes = [];\n            let node = this.first;\n\n            while (node !== this.last) {\n                node = node.nextSibling;\n                nodes.push(node);\n            }\n\n            this.content.append.apply(this.content, nodes);\n            return nodes.length;\n        }\n    \n        const data      = getTarget(object);\n        const observer  = Observer(data);\n        const contents = this.contents;\n        var count = 0;\n\n        // This has to happen synchronously in order to collect gets...\n        contents.forEach((renderer) => count += renderer.update(observer, data));\n\n        // If this.first is not in the content fragment, it must be in the \n        // parent DOM being used as a marker. It's time for its freshly rendered \n        // brethren to join it.\n        if (this.content.firstChild && this.first !== this.content.firstChild) {\n            this.first.after(this.content);\n            ++count;\n        }\n\n        this.observables = observer ?\n            contents.flatMap((renderer) => \n                renderer.paths.map((path) => \n                    // Don't getPath() of the observer here, that really makes \n                    // the machine think too hard\n                    observe(path, data, getPath(path, data)).each((value) =>\n                        // Next renders are cued which batches them\n                        renderer.render(observer)\n                    )\n                )\n            ) :\n            nothing ;\n\n        return count;\n    },\n\n    connect: Renderer.prototype.connect,\n\n    /** \n    .stop()\n    Stops the renderer and all descendent contents. All observers are stopped,\n    handlers registered with `.done()` are called, and no more data can be cued \n    for rendering. Rendered content is left in the DOM, but it is now static.\n    **/\n\n    stop: function() {\n        // We must not empty .contents, they are compiled and cached and may \n        // be cloned. We can stop listening to sets and make .render() a\n        // noop though.\n        //this.contents.forEach(stop);\n        this.observables.forEach(stop);\n        this.observables = nothing;\n        return Renderer.prototype.stop.apply(this, arguments);\n    },\n\n\n    /** \n    .remove()\n    Removes rendered content from the DOM.\n    **/\n    remove: function() {\n        return removeNodes(this.first, this.last);\n    },\n\n    /** \n    .replaceWith()\n    Removes rendered content from the DOM and inserts arguments in its place.\n    **/\n    replaceWith: function() {\n        this.first.before.apply(this.first, arguments);\n        return this.remove();\n    }\n});\n", "\n/** include(src, data)\nIncludes another template. Not available inside attributes.\n**/\n\nimport curry            from '../../fn/modules/curry.js';\nimport request          from './request.js';\nimport { requestGet }   from '../../dom/modules/request.js';\nimport fragmentFromHTML from '../../dom/modules/fragment-from-html.js';\nimport TemplateRenderer from '../modules/renderers/template-renderer.js';\nimport { getTarget }    from '../../fn/observer/observer.js';\n\nexport function include(url, object) {\n    if (!/^#/.test(url)) {\n        return requestGet(url)\n        .then(fragmentFromHTML);\n    }\n\n    const renderer = new TemplateRenderer(url.slice(1));\n\n    // Accept a url, fetch or import it before rendering\n    if (typeof object === 'string') {\n        return request(object)\n        .then((data) => renderer.render(data))\n        .then(() => renderer);\n    }\n\n    // Operate on target to be sure we are not registering gets for data.then \n    // in parent renderer \n    const data = getTarget(object);\n    \n    // Accept a promise of data\n    if (data && data.then) {\n        return data\n        .then((data) => renderer.render(data))\n        .then(() => renderer);\n    }\n\n    // Cue the renderer so that we do not end up collecting read paths read by\n    // the child renderer in the parent.\n    return renderer\n    .render(data || {})\n    .then(() => renderer);\n}\n\nexport default curry(include);\n", "\nimport noop from '../../fn/modules/noop.js';\n\nexport default window.DEBUG ?\n    function log(name, ...args) {\n        if (window.console && window.console.log) {\n            window.console.log('%cdom %c' + name + '%c', 'color: #888888; font-weight: 400;', 'color: #3a8ab0; font-weight: 600;', 'color: inherit; font-weight: 400;', ...args);\n         }\n    } :\n    noop ;\n", "\n/**\nelement(name, options)\n\nRegisters a custom element and returns its constructor.\n\n- name: `'element-name'` or `'tag is=\"element-name\"'`\n- options: {\n    mode:       'open' or 'closed', defaults to 'closed'\n    focusable:  true or false, defaults to true\n    properties: An object of attribute and property handlers\n    \n    // Lifecycle handlers\n    stylesheet: optional string path to stylesheet for shadow DOM\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in \nbrowsers that support the feature. Safari is a known culprit. Mileage will vary.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser \nsupport.\n\nAt the start of initialisation the `construct` handler is called. Use it to\nset up a shadow root and define event handlers. Children and attributes must\nnot be inspected or assigned at this point – doing so will throw in some cases,\neg. construction via `document.createElement()`.\n\nFollowing that, attribute handlers are called for attributes declared in the\nHTML. The parser normally calls these in source order, but this can be problematic\nif you require setup to run in a specific order so here they are run in the order\ndeclared in the `options.properties`.\n\nThen the `connect` handler is called when the element is placed in the DOM\nor if it is already in the DOM and is being upgraded.\n\nFinally the `load` handler is called after the first connect, and after any\nstylesheet links in the shadow DOM have loaded. If there are no links, it is\ncalled immediately after `connect`.\n\nAll lifecycle handlers are called with the parameter `(shadow)`.\n*/\n\nimport create  from './create.js';\nimport capture from '../../fn/modules/capture.js';\nimport log     from './log.js';\n\nconst $internals = Symbol('internals');\nconst $shadow    = Symbol('shadow');\n\nconst define = Object.defineProperties;\n\nconst constructors = {\n    'a':        HTMLAnchorElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function() { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get: function() { return this[$internals].form; }},\n    labels:            { get: function() { return this[$internals].labels; }},\n    validity:          { get: function() { return this[$internals].validity; }},\n    validationMessage: { get: function() { return this[$internals].validationMessage; }},\n    willValidate:      { get: function() { return this[$internals].willValidate; }},\n    checkValidity:     { value: function() { return this[$internals].checkValidity(); }},\n    reportValidity:    { value: function() { return this[$internals].reportValidity(); }}\n};\n\nconst nothing   = {};\nconst onceEvent = { once: true };\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names – not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst captureNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is=[\"']?([a-z][\\w]*-[\\w]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n    \n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction transferProperty(elem, key) {\n    if (elem.hasOwnProperty(key)) {\n        const value = elem[key];\n        delete elem[key];\n        elem[key] = value;\n    }\n\n    return elem;\n}\n\nfunction createShadow(/*template, */elem, options) {\n    elem._initialLoad = true;\n\n    // Create a shadow root if there is DOM content. Shadows may be 'open' or\n    // 'closed'. Closed shadows are not exposed via element.shadowRoot, and\n    // events propagating from inside of them report the element as target.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    elem[$shadow] = shadow;\n\n    return shadow;\n}\n\nfunction attachInternals(elem) {\n    // Use native attachInternals where it exists\n    if (elem.attachInternals) {\n        return elem.attachInternals();\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    const hidden = create('input', { type: 'hidden', name: elem.name });\n\n    // Polyfill internals object setFormValue\n    hidden.setFormValue = function(value) {\n        this.value = value;\n    };\n\n    return hidden;\n}\n\nfunction primeAttributes(elem) {\n    elem._initialAttributes = {};\n    elem._n = 0;\n}\n\nfunction advanceAttributes(elem, attributes, handlers) {\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length && values[attributes[elem._n]] !== undefined) {\n        //console.log('ADVANCE ATTR', attributes[elem._n]);\n        handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        ++elem._n;\n    }\n}\n\nfunction flushAttributes(elem, attributes, handlers) {\n    if (!elem._initialAttributes) { return; }\n\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length) {\n        if (values[attributes[elem._n]] !== undefined && handlers[attributes[elem._n]]) {\n            handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        }\n        ++elem._n;\n    }\n\n    delete elem._initialAttributes;\n    delete elem._n;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api) {\n    const { name, tag } = captureNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n            Object.entries(api).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        // Support the old way, a single options object with props and lifecycle included\n        lifecycle.properties ?\n            Object.entries(lifecycle.properties).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const elem   = Reflect.construct(constructor, arguments, Element);\n        const shadow = lifecycle.construct && lifecycle.construct.length > shadowParameterIndex ?\n            createShadow(elem, lifecycle) :\n            undefined ;\n\n        if (Element.formAssociated) {\n            // Get access to the internal form control API\n            elem[$internals] = attachInternals(elem);\n        }\n\n        if (tag) {\n            supportsCustomisedBuiltIn = true;\n        }\n\n        lifecycle.construct && lifecycle.construct.call(elem, shadow, elem[$internals]);\n\n        // Preserve initialisation order of attribute initialisation by\n        // queueing them\n        if (attributes) {\n            primeAttributes(elem);\n\n            // Wait a tick to flush attributes\n            Promise.resolve(1).then(function() {\n                flushAttributes(elem, Element.observedAttributes, attributes);\n            });\n        }\n\n        // At this point, if properties have already been set before the\n        // element was upgraded, they exist on the elem itself, where we have\n        // just upgraded it's protytype to define those properties those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype\n        //    Object.defineProperties(elem, properties);\n        //\n        // 2. Take a great deal of care not to set properties before an element\n        //    is upgraded. I can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy you have to do this, though.\n        properties\n        && Object.keys(properties).reduce(transferProperty, elem);\n\n        return elem;\n    }\n\n\n    // Properties\n    //\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n\n    const prototype = Element.prototype = Object.create(constructor.prototype, properties) ;\n\n\n    // Form properties\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n        \n        // Define standard form properties\n        define(prototype, formProperties);\n    \n        if (lifecycle.enable || lifecycle.disable) {\n            prototype.formDisabledCallback = function(disabled) {\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, this[$shadow], this[$internals]) :\n                    lifecycle.enable && lifecycle.enable.call(this, this[$shadow], this[$internals]) ;\n            };\n        }\n        \n        if (lifecycle.reset) {\n            prototype.formResetCallback = function() {\n                return lifecycle.reset.call(this, this[$shadow], this[$internals]);\n            };\n        }\n        \n        if (lifecycle.restore) {\n            prototype.formStateRestoreCallback = function() {\n                return lifecycle.restore.call(this, this[$shadow], this[$internals]);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n\n        prototype.attributeChangedCallback = function(name, old, value) {\n            if (!this._initialAttributes) {\n                return attributes[name].call(this, value) ;\n            }\n\n            // Keep a record of attribute values to be applied in\n            // observedAttributes order\n            this._initialAttributes[name] = value;\n            advanceAttributes(this, Element.observedAttributes, attributes);\n        };\n    }\n\n\n    // Lifecycle\n\n    prototype.connectedCallback = function() {\n        const elem      = this;\n        const shadow    = elem[$shadow];\n        const internals = elem[$internals];\n\n        // Initialise any attributes that appeared out of order\n        if (elem._initialAttributes) {\n            flushAttributes(elem, Element.observedAttributes, attributes);\n        }\n\n        // If we have simulated form internals, append the hidden input now\n        if (elem[$internals] && !elem.attachInternals) {\n            elem.appendChild(elem[$internals]);\n        }\n\n        // If this is the first connect and there is an lifecycle.load fn,\n        // _initialLoad is true\n        if (elem._initialLoad) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                let count  = 0;\n                let n = links.length;\n\n                const load = function load(e) {\n                    if (++count >= links.length) {\n                        // Delete _initialLoad. If the element is removed\n                        // and added to the DOM again, stylesheets do not load\n                        // again\n                        delete elem._initialLoad;\n                        if (lifecycle.load) {\n                            lifecycle.load.call(elem, shadow);\n                        }\n                    }\n                };\n\n                // Todo: But do we pick these load events up if the stylesheet \n                // is cached??\n                while (n--) {\n                    links[n].addEventListener('load', load, onceEvent);\n                    links[n].addEventListener('error', function(e) {\n                        if (window.DEBUG) {\n                            console.log('Failed to load stylesheet', e.target.href);\n                        }\n\n                        load(e);\n                    }, onceEvent);\n                }\n\n                if (lifecycle.connect) {\n                    lifecycle.connect.call(this, shadow, internals);\n                }\n            }\n            else {\n                if (lifecycle.connect) {\n                    lifecycle.connect.call(this, shadow, internals);\n                }\n\n                if (lifecycle.load) {\n                    lifecycle.load.call(this, shadow, internals);\n                }\n            }\n        }\n        else if (lifecycle.connect) {\n            lifecycle.connect.call(this, shadow, internals);\n        }\n    }\n\n    if (lifecycle.disconnect) {\n        prototype.disconnectedCallback = function() {\n            return lifecycle.disconnect.call(this, this[$shadow], this[$internals]);\n        };\n    }\n\n    log('element()', '<' + (tag ? tag + ' is=' + name + '' : name) + '>');\n\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Where tag is supplied, element should have been registered as a customised \n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to \n    // go some way towards filling in support by searching for elements and \n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements.\\nAttempting to partially polyfill instances of <' + tag + ' is=\"' + name + '\"> found in the DOM.');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            define(element, properties);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.apply(element);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            lifecycle.connect && lifecycle.connect.apply(element);\n        });\n    }\n\n    return Element;\n}\n", "\n/** \n<literal-include>\n\nA `literal-include` may be placed pretty much anywhere in your HTML, enabling \nthe insertion of chunks of dynamic, JS-rendered DOM wherever you like in a \ndocument.\n\nA `literal-include` finds a source template identified by its `src` attribute,\nfetches JSON or imports a module referred to by its `data` attribute, renders\nattributes and text found to contain literal tags, then replaces itself with \nthe rendered result.\n\nA `literal-include` may contain fallback content, in case any of that fails.\n\n```html\n<template id=\"greetings\">\n    Hello ${ data.name }.\n</template>\n\n<literal-include src=\"#greetings\" data=\"/users/1.json\">\n    Fallback content.\n</literal-include>\n```\n\nMultiple `data-` attributes may be declared, their values become properties of \nthe `data` object inside the template:\n\n```\n<literal-include src=\"#add-to-collections-thumb\" data-pk=\"34\" ... ></literal-include>\n```\n\nOr a single `data` attribute can be used to pass JSON to use as the `data` \nobject inside the template:\n\n```\n<literal-include src=\"#add-to-collections-thumb\" data='{\"pk\":34, ... }'></literal-include>\n```\n\nBoth `data` and `data-` attributes also accept URLs. A URL is used to fetch a \n.json file...\n\n```\n<literal-include src=\"#greetings\" data=\"/users/1.json\"></literal-include>\n```\n\n...or import the default export of a .js module:\n\n```\n<literal-include src=\"#greetings\" data=\"/user-module.js\"></literal-include>\n```\n\n**/\n\nimport noop    from '../../fn/modules/noop.js';\nimport element from '../../dom/modules/element.js';\nimport request from '../library/request.js';\nimport TemplateRenderer from '../modules/renderers/template-renderer.js';\nimport print   from '../library/print.js';\n\nconst rpath = /^\\/|\\.|^https?:\\/\\//;\n\nfunction parseValue(string) {\n    try {\n        return JSON.parse(string);\n    }\n    catch(e) {\n        return string;\n    }\n}\n\nfunction resolveValue(value) {\n    return rpath.test(value) ?\n        request(value) :\n        parseValue(value) ;\n}\n\nfunction zipObject(keys, values) {\n    const object = {};\n    let n = keys.length;\n    while (n--) { object[keys[n]] = values[n]; }\n    return object;\n}\n\nelement('<literal-include>', {\n    construct: function() {\n        if (window.DEBUG && !this.hasAttribute('src')) {\n            console.error('<literal-include> a src attribute is required', this);\n        }\n\n\n        // Resolve data\n\n        const keys   = Object.keys(this.dataset);\n        const values = Object.values(this.dataset); \n        const dataPromise = keys.length ?\n            // where there are values in dataset compose data from dataset\n            Promise\n            .all(values.map(resolveValue))\n            .then((values) => zipObject(keys, values)) :\n\n            // Otherwise wait for data attribute\n            new Promise((resolve, reject) => {\n                this.resolveData = resolve;\n                this.rejectData  = reject;\n            }) ;\n\n\n        // Resolve src\n\n        new Promise((resolve, reject) => {\n            this.resolveSrc = resolve;\n            this.rejectSrc = reject;\n        })\n        .then((template) => dataPromise.then((data) => {\n            const renderer = new TemplateRenderer(template);\n\n            // But once it has data we know we can render it, but we \n            // want to do that in the next batch\n            renderer.render(data).then(() => {\n                this.replaceWith(renderer.content);\n\n                // Signal to tree of renderers that we are now in the DOM\n                renderer.connect();\n                //trigger(renderer, 'connect', 'dom');\n            })/*.catch(window.DEBUG ?\n                (e) => {\n                    this.replaceWith(print(e));\n                    throw e;\n                } :\n                noop\n            );*/\n\n            this.renderer = renderer;\n        })).catch(window.DEBUG ?\n            (e) => {\n                this.replaceWith(print(e));\n                console.error(e.message);\n            } :\n            noop\n        );\n    },\n\n    connect: function() {\n        // Where no data or data-* attribute has been defined resolve with an \n        // empty object...\n        this.resolveData && this.resolveData({});\n    }\n}, {\n    /** \n    data=\"\"\n\n    Defines a JSON file or JS module containing data to be rendered. If a data \n    attribute is not defined and empty object is used.\n\n    To get data from a JSON file specify a path to JSON:\n\n    ```html\n    <literal-include src=\"#greetings\" data=\"./package.json\"></literal-include>\n    ```\n\n    Or import the default export of a JS module:\n\n    ```html\n    <literal-include src=\"#greetings\" data=\"./modules/literal.js\"></literal-include>\n    ```\n\n    Or import a named export of JS module:\n\n    ```html\n    <literal-include src=\"#greetings\" data=\"./modules/literal.js#name\"></literal-include>\n    ```\n    **/\n\n    data: {\n        attribute: function(value) {\n            this.data = value;\n        },\n\n        get: function() {\n            if (this.renderer) {\n                return this.renderer.data;\n            }\n        },\n\n        set: function(value) {\n            if (this.renderer) {\n                if (!value) {\n                    this.renderer.render(null);\n                }\n                else if (typeof value === 'string') {\n                    request(value).then((data) => this.renderer.render(data));\n                }\n                else {\n                    this.renderer.render(value);\n                }\n\n                return;\n            }\n\n            if (!this.resolveData) {\n                //console.log('BOO dont know why this is triggered multiple times', value)\n                throw new Error('<literal-include> may possess either data-* attributes or a single data attribute, not both');\n            }\n\n            if (!value) {\n                return;\n            }\n            else if (typeof value === 'string') {\n                this.resolveData(request(value));\n            }\n            else {\n                this.resolveData(value);\n            }\n        }\n    },\n\n    /**\n    src=\"\"\n\n    Define a source template whose rendered content replaces this\n    `literal-include`. This is a required attribute and must be in the form of\n    a fragment identifier pointing to a `template` element in the DOM.  \n    **/\n\n    src: {\n        attribute: function(value) {\n            if (!value) {\n                return this.rejectSrc(new Error('<literal-include> source src=\"' + value + '\" is empty'));\n            }\n\n            const id = value.replace(/^#/, '');\n            const template = document.getElementById(id);\n\n            if (!template) {\n                return this.rejectSrc(new Error('<literal-include> src template not found'));\n            }\n\n            this.resolveSrc(template);\n        }\n    }\n});\n", "\nimport renderers from './renderers/analytics.js';\n\nexport default {\n    renderers\n};\n", "\n/**\nGet Started\n\nImport Literal from the main module in the repo:\n\n```\nimport 'http://stephen.band/literal/module.js';\n```\n\n<p class=\"right-bubble bubble\">Clearly you should not rely on this resource in \nproduction. Use a bundler such as <a href=\"https://esbuild.github.io/\">esbuild</a> \nto package it into your own module.</p>\n\nAnd grab the associated CSS:\n\n```css\n@import 'http://stephen.band/literal/module.css';\n```\n\n<p class=\"right-bubble bubble\">Clearly you should not rely on this resource in \nproduction. Use a bundler to package it into your own CSS.</p>\n\nThis registers the custom element `<literal-include>`. Here is how to use it:\n\n```html\n<template id=\"item\">\n    <li>${ data.text }</li>\n</template>\n\n<template id=\"todo-list\">\n    <p>Todo list: ${ data.title }</p>\n    <ul>${ data.tasks.map(include('#item')) }</ul>\n</template>\n\n<literal-include src=\"#todo-list\" data=\"./data/todo.json\">\n    <p>Fallback content.</p>\n</literal-include>\n```\n\nA `<literal-include>` is replaced with the content of its `src` template when \nits `data` is fetched and rendered. Inside the template, data to render \nis accessed through the variable `${ data }`. The result of this example is:\n\n<template id=\"item\">\n    <li>${ data.text }</li>\n</template>\n\n<template id=\"author\">\n    <p>Todo list: ${ data.title }</p>\n    <ul>${ data.tasks.map(include('#item')) }</ul>\n</template>\n\n<literal-include src=\"#author\" data=\"./data/todo.json\">\n    <p>Fallback content.</p>\n</literal-include>\n\nThe template renderer observes `data` objects and updates the DOM if changes are \ndetected. In the following example a mutating `data` object is imported from a \nJS module and used to rotate an SVG:\n\n```html\n<template id=\"clock\">\n    <svg style=\"transform: rotate(${ round(data.time) * 6 + 'deg'});\" viewBox=\"0 0 24 24\">\n        <circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"white\" />\n        <line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"1\" />\n    </svg>\n    <p>You loaded this <b>${ round(data.time) + 's' }</b> ago.</p>\n</template>\n\n<literal-include src=\"#clock\" data=\"./data/dom-clock.js\">\n    <p>You loaded this.</p>\n</literal-include>\n```\n\nAnd the result is:\n\n<template id=\"clock\">\n    <svg style=\"transform: rotate(${ round(data.time) * 6 + 'deg'});\" viewBox=\"0 0 24 24\" width=\"32\" height=\"32\">\n        <circle cx=\"12\" cy=\"12\" r=\"11\" fill=\"white\" stroke-width=\"2\" />\n        <line x1=\"12\" y1=\"12\" x2=\"12\" y2=\"1\" stroke-width=\"1\" />\n    </svg>\n    <p>You loaded this <b>${ round(data.time) + 's' }</b> ago.</p>\n</template>\n\n<literal-include src=\"#clock\" data=\"./data/dom-clock.js\">\n    <p>You loaded this.</p>\n</literal-include>\n**/\n\n/*\nContents\n- <a href=\"#literal-include\">`<literal-include>`</a>\n- <a href=\"#template-functions\">Literal template functions</a>\n*/\n\nimport include from './library/include.js';\nimport request from './library/request.js';\n\n/* Importing literal-include registers – and instantiates – <literal-include> */\nimport './elements/literal-include.js';\n\nexport { cache as compiled } from './modules/compile.js';\nimport { register } from './modules/library.js';\n\nimport analytics from './modules/analytics.js';\nexport { analytics };\n\nregister('include', include);\nregister('request', request);\n\nexport { register };\nexport { default as Template } from './modules/renderers/template-renderer.js';\n\nexport { Observer }  from '../fn/observer/observer.js';\nexport { default as observe } from '../fn/observer/observe.js';\n"],
  "mappings": "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",
  "names": []
}
